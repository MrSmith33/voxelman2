/// Copyright: Copyright (c) 2021-2022 Andrey Penechko.
/// License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).
/// Authors: Andrey Penechko.
module hello_triangle.main;

import core.enet;
import core.glfw3;
import core.host;
import core.kernel32;
import core.mdbx;
import core.shaderc;
import core.tracy;
import core.utils;
import core.vector;
import core.vulkan.functions;
import core.vulkan.types;


void main()
{
	__init_utils();

	Client client;
	client.run();
}

enum TRACY_ON = 1;

u8[] frame_name = "Frame";

struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR  capabilities;
	Array[VkSurfaceFormatKHR] formats;
	Array[VkPresentModeKHR]   presentModes;

	void free() {
		formats.free();
		presentModes.free();
	}
}

struct Client
{
	void run()
	{
		init();
		mainLoop();
		free();
	}


	GLFWwindow* window;
	MDBX_env* mdbxEnv;

	VkInstance instance;
	VkDebugUtilsMessengerEXT debugMessenger;
	VkSurfaceKHR surface;

	VkPhysicalDevice physicalDevice;
	SwapChainSupportDetails swapChainSupport; // result of querySwapChainSupport on physicalDevice
	VkDevice device; // logical device

	VkQueue graphicsQueue;
	VkQueue presentQueue;

	VkSwapchainKHR swapChain;
	VkImage[] swapChainImages;
	VkFormat swapChainImageFormat;
	VkExtent2D swapChainExtent;
	VkImageView[] swapChainImageViews;
	VkFramebuffer[] swapChainFramebuffers;

	VkShaderModule vertShaderModule;
	VkShaderModule fragShaderModule;

	VkRenderPass renderPass;
	VkPipelineLayout pipelineLayout;
	VkPipeline graphicsPipeline;

	VkCommandPool commandPool;
	VkCommandBuffer[] commandBuffers;

	VkSemaphore[] imageAvailableSemaphores;
	VkSemaphore[] renderFinishedSemaphores;
	VkFence[] inFlightFences;
	u32 currentFrame = 0;

	bool framebufferResized = false;

	enum u32 MAX_FRAMES_IN_FLIGHT = 2;
	enum WIDTH = 800;
	enum HEIGHT = 600;

	enum PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR;

	bool enableValidationLayers = true;
	u8*[1] validationLayers;
	u8*[1] deviceExtensions;

	Vertex[4] vertices;
	u16[6] indicies;
	VkBuffer vertexBuffer;
	VkDeviceMemory vertexBufferMemory;
	VkBuffer indexBuffer;
	VkDeviceMemory indexBufferMemory;

	bool isRunning = true;


	void init()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.init", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		validationLayers[0] = "VK_LAYER_KHRONOS_validation";
		deviceExtensions[0] = "VK_KHR_swapchain";

		vertices[0] = Vertex(vec2(-0.5, -0.5), vec3(1, 0, 0));
		vertices[1] = Vertex(vec2( 0.5, -0.5), vec3(0, 1, 0));
		vertices[2] = Vertex(vec2( 0.5,  0.5), vec3(0, 0, 1));
		vertices[3] = Vertex(vec2(-0.5,  0.5), vec3(1, 1, 1));
		indicies[0] = 0;
		indicies[1] = 1;
		indicies[2] = 2;
		indicies[3] = 2;
		indicies[4] = 3;
		indicies[5] = 0;

		initWindow();
		initVulkan();
		if (!isRunning) return;

		@static TracyLoc zone1 = TracyLoc(null, "enet_initialize", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		enet_initialize();
		tracy_emit_zone_end(ctx1);

		u8[] path = "test.db";
		@static TracyLoc zone2 = TracyLoc(null, "mdbx_env_create", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		mdbx_env_create(&mdbxEnv);
		tracy_emit_zone_end(ctx2);
		@static TracyLoc zone3 = TracyLoc(null, "mdbx_env_open", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
		mdbx_env_open(
			mdbxEnv,
			path.ptr,
			MDBX_env_flags_t.MDBX_NOSUBDIR |
			MDBX_env_flags_t.MDBX_EXCLUSIVE,
			//rwx_rwx_rwx
			0b110_110_110);
		tracy_emit_zone_end(ctx3);

		tracy_emit_zone_end(ctx);
	}

	void initWindow()
	{
		@static TracyLoc zone1 = TracyLoc(null, "Client.initWindow", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone1, TRACY_ON);

		@static TracyLoc zone2 = TracyLoc(null, "glfwInit", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwInit = tracy_emit_zone_begin(&zone2, TRACY_ON);
		if (!glfwInit()) {
			println("GLFW init failed");
			isRunning = false;
			tracy_emit_zone_end(ctx_glfwInit);
			tracy_emit_zone_end(ctx);
			return;
		}
		tracy_emit_zone_end(ctx_glfwInit);

		// Do not create OpenGL context
		@static TracyLoc zone3 = TracyLoc(null, "glfwWindowHint", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwWindowHint = tracy_emit_zone_begin(&zone3, TRACY_ON);
		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
		tracy_emit_zone_end(ctx_glfwWindowHint);

		@static TracyLoc zone4 = TracyLoc(null, "glfwCreateWindow", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwCreateWindow = tracy_emit_zone_begin(&zone4, TRACY_ON);
		window = glfwCreateWindow(WIDTH, HEIGHT, "Voxelman - Vulkan Hello Triangle", null, null);
		tracy_emit_zone_end(ctx_glfwCreateWindow);

		@static TracyLoc zone5 = TracyLoc(null, "glfwSetWindowUserPointer", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwSetWindowUserPointer = tracy_emit_zone_begin(&zone5, TRACY_ON);
		glfwSetWindowUserPointer(window, this);
		tracy_emit_zone_end(ctx_glfwSetWindowUserPointer);

		@static TracyLoc zone6 = TracyLoc(null, "glfwSetKeyCallback", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwSetKeyCallback = tracy_emit_zone_begin(&zone6, TRACY_ON);
		glfwSetKeyCallback(window, &glfw_key_callback);
		tracy_emit_zone_end(ctx_glfwSetKeyCallback);

		@static TracyLoc zone7 = TracyLoc(null, "glfwSetFramebufferSizeCallback", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_glfwSetFBCallback = tracy_emit_zone_begin(&zone7, TRACY_ON);
		glfwSetFramebufferSizeCallback(window, &glfw_framebuffer_resize_callback);
		tracy_emit_zone_end(ctx_glfwSetFBCallback);

		tracy_emit_zone_end(ctx);
	}

	@static void glfw_key_callback(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods)
	{
		Client* client = cast(Client*)glfwGetWindowUserPointer(window);
		client.onKey(key, scancode, action, mods);
	}

	@static void glfw_framebuffer_resize_callback(GLFWwindow* window, i32 width, i32 height)
	{
		Client* client = cast(Client*)glfwGetWindowUserPointer(window);
		client.onFramebufferResize(width, height);
	}

	void initVulkan()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.initVulkan", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (!glfwVulkanSupported) {
			println("Vulkan is not supported");
			isRunning = false;
			return;
		}

		loadGlobalLevelFunctions( cast(PFN_vkGetInstanceProcAddr)glfwGetInstanceProcAddress(null, "vkGetInstanceProcAddr"));

		createInstance();
		if (!isRunning) return;
		setupDebugMessenger();
		if (!isRunning) return;
		createSurface();
		if (!isRunning) return;
		pickPhysicalDevice();
		if (!isRunning) return;
		createLogicalDevice();
		if (!isRunning) return;
		createSwapChain();
		if (!isRunning) return;
		createImageViews();
		if (!isRunning) return;
		createRenderPass();
		if (!isRunning) return;
		loadShaders();
		if (!isRunning) return;
		createGraphicsPipeline();
		if (!isRunning) return;
		createFramebuffers();
		if (!isRunning) return;
		createCommandPool();
		if (!isRunning) return;
		createVertexBuffer();
		if (!isRunning) return;
		createIndexBuffer();
		if (!isRunning) return;
		createCommandBuffers();
		if (!isRunning) return;
		createSyncObjects();

		tracy_emit_zone_end(ctx);
	}

	void mainLoop()
	{
		while(isRunning && !glfwWindowShouldClose(window)) {
			update();
			drawFrame();
			tracy_emit_frame_mark();
		}

		vkDeviceWaitIdle(device);
	}

	void update()
	{
		@static TracyLoc zone_loc1 = TracyLoc(null, "glfwPollEvents", "main.vx", cast(u32)__LINE__, 0x00AA00); TracyZoneCtx tracy_ctx1 = tracy_emit_zone_begin(&zone_loc1, TRACY_ON);
		glfwPollEvents();
		tracy_emit_zone_end(tracy_ctx1);
		//@static TracyLoc zone_loc2 = TracyLoc(null, "sleep(1)", "main.vx", cast(u32)__LINE__, 0x00CC00); TracyZoneCtx tracy_ctx2 = tracy_emit_zone_begin(&zone_loc2, TRACY_ON);
		//Sleep(1);
		//tracy_emit_zone_end(tracy_ctx2);
	}

	void free()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.free", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		mdbx_env_close_ex(mdbxEnv);
		enet_deinitialize();
		freeVulkan();
		freeWindow();

		tracy_emit_zone_end(ctx);
	}

	void freeVulkan()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.freeVulkan", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		swapChainSupport.free();

		vkDestroyShaderModule(device, vertShaderModule, null);
		vkDestroyShaderModule(device, fragShaderModule, null);

		cleanupSwapChain();

		vkDestroyBuffer(device, indexBuffer, null);
		vkFreeMemory(device, indexBufferMemory, null);

		vkDestroyBuffer(device, vertexBuffer, null);
		vkFreeMemory(device, vertexBufferMemory, null);

		for (u64 i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i) {
			vkDestroySemaphore(device, renderFinishedSemaphores[i], null);
			vkDestroySemaphore(device, imageAvailableSemaphores[i], null);
			vkDestroyFence(device, inFlightFences[i], null);
		}

		vkDestroyCommandPool(device, commandPool, null);

		vkDestroyDevice(device, null);

		if (enableValidationLayers) {
			vkDestroyDebugUtilsMessengerEXT(instance, debugMessenger, null);
		}

		vkDestroySurfaceKHR(instance, surface, null);
		vkDestroyInstance(instance, null);

		tracy_emit_zone_end(ctx);
	}

	void freeWindow()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.freeWindow", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		glfwDestroyWindow(window);
		glfwTerminate();

		tracy_emit_zone_end(ctx);
	}

	void cleanupSwapChain() {
		for (u64 i = 0; i < swapChainFramebuffers.length; ++i) {
			vkDestroyFramebuffer(device, swapChainFramebuffers[i], null);
		}

		vkDestroyPipeline(device, graphicsPipeline, null);
		vkDestroyPipelineLayout(device, pipelineLayout, null);
		vkDestroyRenderPass(device, renderPass, null);

		for (u64 i = 0; i < swapChainImageViews.length; ++i) {
			vkDestroyImageView(device, swapChainImageViews[i], null);
		}
		//swapChainImageViews = freeArray[VkImageView](swapChainImageViews);

		vkDestroySwapchainKHR(device, swapChain, null);
	}

	void recreateSwapChain() {
		@static TracyLoc zone = TracyLoc(null, "Client.recreateSwapChain", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		// Pause if window was minimized
		i32 width;
		i32 height;
		glfwGetFramebufferSize(window, &width, &height);
		while (width == 0 || height == 0) {
			glfwGetFramebufferSize(window, &width, &height);
			glfwWaitEvents();
		}

		framebufferResized = false;

		vkDeviceWaitIdle(device);

		cleanupSwapChain();

		createSwapChain();
		if (!isRunning) return;
		createImageViews();
		if (!isRunning) return;
		createRenderPass();
		if (!isRunning) return;
		createGraphicsPipeline();
		if (!isRunning) return;
		createFramebuffers();

		tracy_emit_zone_end(ctx);
	}

	void createInstance()
	{
		@static TracyLoc zone = TracyLoc(null, "Client.createInstance", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkApplicationInfo appInfo;
		appInfo.pApplicationName = "Hello Triangle";
		appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
		appInfo.pEngineName = "Voxelman";
		appInfo.engineVersion = VK_MAKE_VERSION(2, 0, 0);
		appInfo.apiVersion = VK_API_VERSION_1_0;

		VkInstanceCreateInfo createInfo;
		createInfo.pApplicationInfo = &appInfo;

		Array[u8*] extensions = getRequiredExtensions;

		//println("Requesting ", extensions.length, " extensions:");
		//for (i32 i; i < extensions.length; ++i) {
		//	println("  ", extensions.ptr[i].fromStringz);
		//}

		createInfo.enabledExtensionCount = extensions.length;
		createInfo.ppEnabledExtensionNames = extensions.ptr;

		VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
		if (enableValidationLayers) {
			if (!checkValidationLayerSupport()) {
				println("Validation layers requested, but not available!");
			} else {
				createInfo.enabledLayerCount = cast(u32)validationLayers.length;
				createInfo.ppEnabledLayerNames = validationLayers.ptr;

				populateDebugMessengerCreateInfo(&debugCreateInfo);
				createInfo.pNext = &debugCreateInfo;
			}
		} else {
			createInfo.enabledLayerCount = 0;
		}

		//println("vkCreateInstance ", cast(void*)vkCreateInstance, " ", cast(void*)&createInfo, " ", cast(void*)&appInfo);

		@static TracyLoc zone1 = TracyLoc(null, "vkCreateInstance", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		i32 vkCreateInstanceResult = cast(i32)vkCreateInstance(&createInfo, null, &instance);
		tracy_emit_zone_end(ctx1);

		if (vkCreateInstanceResult != VK_SUCCESS) {
			println("vkCreateInstance failed: ", vkCreateInstanceResult);
			isRunning = false;
			tracy_emit_zone_end(ctx);
			return;
		}
		//println("VkInstance ", cast(void*)instance);

		@static TracyLoc zone2 = TracyLoc(null, "loadInstanceLevelFunctions", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		loadInstanceLevelFunctions(instance);
		tracy_emit_zone_end(ctx2);

		//{
		//	u32 extensionCount;
		//	vkEnumerateInstanceExtensionProperties(null, &extensionCount, null);
		//	println("\n", extensionCount, " instance extensions supported");
		//	VkExtensionProperties[] extensions = makeArray[VkExtensionProperties](extensionCount);
		//	vkEnumerateInstanceExtensionProperties(null, &extensionCount, extensions.ptr);
		//	for (i32 i; i < extensionCount; ++i) {
		//		println("  ", extensions[i].extensionName.ptr.fromStringz, " ", extensions[i].specVersion);
		//	}
		//	freeArray[VkExtensionProperties](extensions);
		//}

		tracy_emit_zone_end(ctx);
	}

	void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT* createInfo) {
		createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
		//createInfo.messageSeverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
		createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
		createInfo.pfnUserCallback = &debugCallback;
		createInfo.pUserData = null; // Optional
	}

	void setupDebugMessenger() {
		@static TracyLoc zone = TracyLoc(null, "Client.setupDebugMessenger", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (!enableValidationLayers) {
			tracy_emit_zone_end(ctx);
			return;
		}

		VkDebugUtilsMessengerCreateInfoEXT createInfo;
		populateDebugMessengerCreateInfo(&createInfo);

		if (vkCreateDebugUtilsMessengerEXT(instance, &createInfo, null, &debugMessenger) != VK_SUCCESS) {
			println("failed to set up debug messenger!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);
	}

	void createSurface() {
		@static TracyLoc zone = TracyLoc(null, "Client.createSurface", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (glfwCreateWindowSurface(instance, window, null, &surface) != VK_SUCCESS) {
			println("failed to create window surface!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);
	}

	bool checkValidationLayerSupport() {
		@static TracyLoc zone = TracyLoc(null, "Client.checkValidationLayerSupport", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		u32 layerCount;
		vkEnumerateInstanceLayerProperties(&layerCount, null);
		VkLayerProperties[] availableLayers = makeArray[VkLayerProperties](layerCount);
		vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.ptr);
		println("\n", layerCount, " layers supported");

		bool hasAllLayers = checkLayers(validationLayers, availableLayers);

		freeArray[VkLayerProperties](availableLayers);

		tracy_emit_zone_end(ctx);
		return hasAllLayers;
	}

	Array[u8*] getRequiredExtensions() {
		Array[u8*] extensions;

		u32 glfwExtensionCount = 0;
		u8** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

		extensions.putArray(glfwExtensions[0..glfwExtensionCount]);

		if (enableValidationLayers) {
			extensions.put(VK_EXT_DEBUG_UTILS_EXTENSION_NAME.ptr);
		}

		return extensions;
	}

	void pickPhysicalDevice() {
		@static TracyLoc zone = TracyLoc(null, "Client.pickPhysicalDevice", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		u32 deviceCount = 0;
		vkEnumeratePhysicalDevices(instance, &deviceCount, null);

		if (deviceCount == 0) {
			println("failed to find GPUs with Vulkan support!");
			isRunning = false;
			tracy_emit_zone_end(ctx);
			return;
		}

		VkPhysicalDevice[] devices = makeArray[VkPhysicalDevice](deviceCount);
		vkEnumeratePhysicalDevices(instance, &deviceCount, devices.ptr);

		println("Found ", deviceCount, " devices:");

		i64 bestDeviceScore = 0;
		for (u32 i; i < deviceCount; ++i) {
			SwapChainSupportDetails deviceSwapChainDetails;
			i64 deviceScore = rateDeviceSuitability(devices[i], &deviceSwapChainDetails);
			if (deviceScore > bestDeviceScore) {
				bestDeviceScore = deviceScore;
				physicalDevice = devices[i];
				swapChainSupport.free();
				swapChainSupport = deviceSwapChainDetails;
			}
		}

		freeArray[VkPhysicalDevice](devices);

		if (physicalDevice == null) {
			println("failed to find a suitable GPU!");
			isRunning = false;
			tracy_emit_zone_end(ctx);
			return;
		}

		println("Selected device ", physicalDevice, " with score ", bestDeviceScore);

		tracy_emit_zone_end(ctx);
	}

	// negative score means that device is unsuitable
	i64 rateDeviceSuitability(VkPhysicalDevice device, SwapChainSupportDetails* deviceSwapChainSupport) {
		@static TracyLoc zone = TracyLoc(null, "Client.rateDeviceSuitability", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		VkPhysicalDeviceProperties deviceProperties;
		vkGetPhysicalDeviceProperties(device, &deviceProperties);

		println("  ", device, " ", deviceProperties.deviceName.ptr.fromStringz);

		VkPhysicalDeviceFeatures deviceFeatures;
		vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

		i64 score = 0;

		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
			score += 1000;
			println("    discrete GPU");
		}

		QueueFamilyIndices indices = findQueueFamilies(device);

		if (!indices.isComplete) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		bool extensionsSupported = checkDeviceExtensionSupport(device);
		if (!extensionsSupported) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		bool swapChainAdequate = false;
		if (extensionsSupported) {
			querySwapChainSupport(device, deviceSwapChainSupport);
			swapChainAdequate = deviceSwapChainSupport.formats.length > 0 && deviceSwapChainSupport.presentModes.length > 0;
		}
		if (!swapChainAdequate) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		tracy_emit_zone_end(ctx);
		return score;
	}

	QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
		QueueFamilyIndices indices;

		u32 queueFamilyCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, null);

		VkQueueFamilyProperties[] queueFamilies = makeArray[VkQueueFamilyProperties](queueFamilyCount);
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.ptr);

		for (u32 i; i < queueFamilyCount; ++i) {
			VkQueueFamilyProperties queueFamily = queueFamilies[i];
			if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
				indices.presentFamilies |= QueueFamilyFlags.graphics;
				indices.indices[QueueFamily.graphics] = i;
			}

			VkBool32 presentSupport = false;
			vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
			if (presentSupport) {
				indices.presentFamilies |= QueueFamilyFlags.present;
				indices.indices[QueueFamily.present] = i;
			}
			if (indices.isComplete) break;
		}

		freeArray[VkQueueFamilyProperties](queueFamilies);

		return indices;
	}

	//bool isDeviceSuitable(VkPhysicalDevice device) {
	//	VkPhysicalDeviceProperties deviceProperties;
	//	vkGetPhysicalDeviceProperties(device, &deviceProperties);

	//	VkPhysicalDeviceFeatures deviceFeatures;
	//	vkGetPhysicalDeviceFeatures(device, &deviceFeatures);
	//	return true;
	//}

	bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
		u32 extensionCount;
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, null);

		VkExtensionProperties[] availableExtensions = makeArray[VkExtensionProperties](extensionCount);
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, availableExtensions.ptr);

		//println("    ", extensionCount, " device extensions");
		//for (u32 i; i < extensionCount; ++i) {
		//	u8[] name = availableExtensions[i].extensionName.ptr.fromStringz;
		//	println("      ", name, " ", availableExtensions[i].specVersion);
		//}

		bool hasAllExtensions = checkExtensions(deviceExtensions, availableExtensions);

		freeArray[VkExtensionProperties](availableExtensions);

		return hasAllExtensions;
	}

	void createLogicalDevice() {
		@static TracyLoc zone = TracyLoc(null, "Client.createLogicalDevice", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
		println("Queues");
		println("  Graphics: ", indices.indices[QueueFamily.graphics]);
		println("   Present: ", indices.indices[QueueFamily.present]);


		// Specify queues to be created in logical device
		Array[VkDeviceQueueCreateInfo] queueCreateInfos;

		f32 queuePriority = 1.0;
		for (u32 i = 0; i < QueueFamilyIndices.NUM_FAMILIES; ++i) {

			bool alreadyExists = false;
			for (u32 j = 0; j < i; ++j) {
				if (indices.indices[i] == indices.indices[j]) {
					alreadyExists = true;
					break;
				}
			}
			if (alreadyExists) continue;

			VkDeviceQueueCreateInfo queueCreateInfo;
			queueCreateInfo.queueFamilyIndex = indices.indices[i];
			queueCreateInfo.queueCount = 1;
			queueCreateInfo.pQueuePriorities = &queuePriority;
			queueCreateInfos.put(queueCreateInfo);
		}


		// Create logical device
		VkDeviceCreateInfo createInfo;

		createInfo.pQueueCreateInfos = queueCreateInfos.ptr;
		createInfo.queueCreateInfoCount = cast(u32)queueCreateInfos.length;

		createInfo.enabledExtensionCount = cast(u32)deviceExtensions.length;
		createInfo.ppEnabledExtensionNames = deviceExtensions.ptr;

		if (enableValidationLayers) {
			createInfo.enabledLayerCount = cast(u32)validationLayers.length;
			createInfo.ppEnabledLayerNames = validationLayers.ptr;
		} else {
			createInfo.enabledLayerCount = 0;
		}

		VkPhysicalDeviceFeatures deviceFeatures;
		createInfo.pEnabledFeatures = &deviceFeatures;

		@static TracyLoc zone1 = TracyLoc(null, "vkCreateDevice", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		VkResult vkCreateDeviceResult = vkCreateDevice(physicalDevice, &createInfo, null, &device);
		tracy_emit_zone_end(ctx1);
		queueCreateInfos.free();
		if (vkCreateDeviceResult != VK_SUCCESS) {
			println("failed to create logical device: ");
			isRunning = false;
			tracy_emit_zone_end(ctx);
			return;
		}
		println("Logical device ", device);


		// Load functions of this specific device. Only support single device for now
		// For multiple devices either use `loadDeviceLevelFunctions` or `DispatchDevice`
		@static TracyLoc zone2 = TracyLoc(null, "loadDeviceLevelFunctionsDirect", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		loadDeviceLevelFunctionsDirect(device);
		tracy_emit_zone_end(ctx2);


		// Retreive queue handles of queues we requested
		vkGetDeviceQueue(device, indices.indices[QueueFamily.graphics], 0, &graphicsQueue);
		vkGetDeviceQueue(device, indices.indices[QueueFamily.present],  0, &presentQueue);

		tracy_emit_zone_end(ctx);
	}

	void createSwapChain() {
		@static TracyLoc zone = TracyLoc(null, "Client.createSwapChain", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
		VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
		VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);

		u32 imageCount = swapChainSupport.capabilities.minImageCount + 1;
		if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {
			imageCount = swapChainSupport.capabilities.maxImageCount;
		}

		VkSwapchainCreateInfoKHR createInfo;
		createInfo.surface = surface;

		createInfo.minImageCount = imageCount;
		createInfo.imageFormat = surfaceFormat.format;
		createInfo.imageColorSpace = surfaceFormat.colorSpace;
		createInfo.imageExtent = extent;
		createInfo.imageArrayLayers = 1;
		createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

		QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

		if (indices.indices[QueueFamily.graphics] != indices.indices[QueueFamily.present]) {
			createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
			createInfo.queueFamilyIndexCount = cast(u32)indices.indices.length;
			createInfo.pQueueFamilyIndices = indices.indices.ptr;
		} else {
			createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
			// createInfo.queueFamilyIndexCount = 0; // noop
			// createInfo.pQueueFamilyIndices = null; // noop
		}

		createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
		createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
		createInfo.presentMode = presentMode;
		createInfo.clipped = VK_TRUE;

		createInfo.oldSwapchain = null;

		@static TracyLoc zone2 = TracyLoc(null, "vkCreateSwapchainKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx_vkCreateSwapchainKHR = tracy_emit_zone_begin(&zone2, TRACY_ON);
		if (vkCreateSwapchainKHR(device, &createInfo, null, &swapChain) != VK_SUCCESS) {
			println("failed to create swap chain!");
			isRunning = false;
			tracy_emit_zone_end(ctx_vkCreateSwapchainKHR);
			tracy_emit_zone_end(ctx);
			return;
		}
		tracy_emit_zone_end(ctx_vkCreateSwapchainKHR);

		u32 swapChainImageCount;
		vkGetSwapchainImagesKHR(device, swapChain, &swapChainImageCount, null);
		swapChainImages = resizeArray[VkImage](swapChainImages, swapChainImageCount);
		vkGetSwapchainImagesKHR(device, swapChain, &swapChainImageCount, swapChainImages.ptr);

		swapChainImageFormat = surfaceFormat.format;
		swapChainExtent = extent;

		swapChainSupport.free();

		tracy_emit_zone_end(ctx);
	}

	void createImageViews() {
		@static TracyLoc zone = TracyLoc(null, "Client.createImageViews", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		swapChainImageViews = resizeArray[VkImageView](swapChainImageViews, swapChainImages.length);

		for (u64 i = 0; i < swapChainImages.length; ++i) {
			VkImageViewCreateInfo createInfo;
			createInfo.image = swapChainImages[i];
			createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
			createInfo.format = swapChainImageFormat;
			createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(device, &createInfo, null, &swapChainImageViews[i]) != VK_SUCCESS) {
				println("failed to create image views!");
				isRunning = false;
				tracy_emit_zone_end(ctx);
				return;
			}
		}
		tracy_emit_zone_end(ctx);
	}

	void createRenderPass() {
		@static TracyLoc zone = TracyLoc(null, "Client.createRenderPass", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkAttachmentDescription colorAttachment;
		colorAttachment.format = swapChainImageFormat;
		colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
		colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
		colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
		colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

		VkAttachmentReference colorAttachmentRef;
		colorAttachmentRef.attachment = 0;
		colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		VkSubpassDescription subpass;
		subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		subpass.colorAttachmentCount = 1;
		subpass.pColorAttachments = &colorAttachmentRef;

		VkSubpassDependency dependency;
		dependency.srcSubpass = cast(u32)VK_SUBPASS_EXTERNAL;
		dependency.dstSubpass = 0;
		dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency.srcAccessMask = 0;
		dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

		VkRenderPassCreateInfo renderPassInfo;
		renderPassInfo.attachmentCount = 1;
		renderPassInfo.pAttachments = &colorAttachment;
		renderPassInfo.subpassCount = 1;
		renderPassInfo.pSubpasses = &subpass;
		renderPassInfo.dependencyCount = 1;
		renderPassInfo.pDependencies = &dependency;

		if (vkCreateRenderPass(device, &renderPassInfo, null, &renderPass) != VK_SUCCESS) {
			println("failed to create render pass!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);
	}

	void loadShaders() {
		@static TracyLoc zone = TracyLoc(null, "Client.loadShaders", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static TracyLoc zone1 = TracyLoc("vertShaderSource", "utils.readFile", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		u8[] vertShaderSource = readFile("../plugins/hello_triangle/res/shader.vert");
		tracy_emit_zone_end(ctx1);
		@static TracyLoc zone2 = TracyLoc("fragShaderSource", "utils.readFile", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		u8[] fragShaderSource = readFile("../plugins/hello_triangle/res/shader.frag");
		tracy_emit_zone_end(ctx2);

		if (!isRunning) {
			tracy_emit_zone_end(ctx);
			return;
		}

		shaderc_compiler_t compiler = shaderc_compiler_initialize();
		u8[] vertShaderCode = compileShader(compiler, vertShaderSource, "shader.vert", "main", shaderc_shader_kind.shaderc_glsl_vertex_shader);
		u8[] fragShaderCode = compileShader(compiler, fragShaderSource, "shader.frag", "main", shaderc_shader_kind.shaderc_glsl_fragment_shader);
		if (vertShaderCode.length == 0 || fragShaderCode.length == 0) {
			isRunning = false; // error compiling
		}
		@static TracyLoc zone3 = TracyLoc(null, "shaderc_compiler_release", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
		shaderc_compiler_release(compiler);
		tracy_emit_zone_end(ctx3);

		vertShaderModule = createShaderModule(vertShaderCode);
		fragShaderModule = createShaderModule(fragShaderCode);

		freeArray[u8](vertShaderCode);
		freeArray[u8](fragShaderCode);

		tracy_emit_zone_end(ctx);
	}

	void createGraphicsPipeline() {
		@static TracyLoc zone = TracyLoc(null, "Client.createGraphicsPipeline", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkPipelineShaderStageCreateInfo vertShaderStageInfo;
		vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
		vertShaderStageInfo.Module = vertShaderModule;
		vertShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo fragShaderStageInfo;
		fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
		fragShaderStageInfo.Module = fragShaderModule;
		fragShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo[2] shaderStages;
		shaderStages[0] = vertShaderStageInfo;
		shaderStages[1] = fragShaderStageInfo;

		VkPipelineVertexInputStateCreateInfo vertexInputInfo;
		vertexInputInfo.vertexBindingDescriptionCount = 0;
		vertexInputInfo.vertexAttributeDescriptionCount = 0;

		VkVertexInputBindingDescription bindingDescription = Vertex.getBindingDescription();
		VkVertexInputAttributeDescription[2] attributeDescriptions = Vertex.getAttributeDescriptions();

		vertexInputInfo.vertexBindingDescriptionCount = 1;
		vertexInputInfo.vertexAttributeDescriptionCount = cast(u32)attributeDescriptions.length;
		vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
		vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.ptr;

		VkPipelineInputAssemblyStateCreateInfo inputAssembly;
		inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		inputAssembly.primitiveRestartEnable = VK_FALSE;

		VkViewport viewport;
		viewport.x = 0.0;
		viewport.y = 0.0;
		viewport.width = cast(f32)swapChainExtent.width;
		viewport.height = cast(f32)swapChainExtent.height;
		viewport.minDepth = 0.0;
		viewport.maxDepth = 1.0;

		VkRect2D scissor;
		scissor.offset = VkOffset2D(0, 0);
		scissor.extent = swapChainExtent;

		VkPipelineViewportStateCreateInfo viewportState;
		viewportState.viewportCount = 1;
		viewportState.pViewports = &viewport;
		viewportState.scissorCount = 1;
		viewportState.pScissors = &scissor;

		VkPipelineRasterizationStateCreateInfo rasterizer;
		rasterizer.depthClampEnable = VK_FALSE;
		rasterizer.rasterizerDiscardEnable = VK_FALSE;
		rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
		rasterizer.lineWidth = 1.0;
		rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
		rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
		rasterizer.depthBiasEnable = VK_FALSE;

		VkPipelineMultisampleStateCreateInfo multisampling;
		multisampling.sampleShadingEnable = VK_FALSE;
		multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

		VkPipelineColorBlendAttachmentState colorBlendAttachment;
		colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
		colorBlendAttachment.blendEnable = VK_FALSE;

		VkPipelineColorBlendStateCreateInfo colorBlending;
		colorBlending.logicOpEnable = VK_FALSE;
		colorBlending.logicOp = VK_LOGIC_OP_COPY;
		colorBlending.attachmentCount = 1;
		colorBlending.pAttachments = &colorBlendAttachment;
		colorBlending.blendConstants[0] = 0.0;
		colorBlending.blendConstants[1] = 0.0;
		colorBlending.blendConstants[2] = 0.0;
		colorBlending.blendConstants[3] = 0.0;

		VkPipelineLayoutCreateInfo pipelineLayoutInfo;
		pipelineLayoutInfo.setLayoutCount = 0; // Optional
		pipelineLayoutInfo.pSetLayouts = null; // Optional
		pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional
		pipelineLayoutInfo.pPushConstantRanges = null; // Optional

		@static TracyLoc zone4 = TracyLoc(null, "vkCreatePipelineLayout", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, null, &pipelineLayout) != VK_SUCCESS) {
			println("failed to create pipeline layout!");
			isRunning = false;
		}
		tracy_emit_zone_end(ctx4);

		VkGraphicsPipelineCreateInfo pipelineInfo;
		pipelineInfo.stageCount = 2;
		pipelineInfo.pStages = shaderStages.ptr;
		pipelineInfo.pVertexInputState = &vertexInputInfo;
		pipelineInfo.pInputAssemblyState = &inputAssembly;
		pipelineInfo.pViewportState = &viewportState;
		pipelineInfo.pRasterizationState = &rasterizer;
		pipelineInfo.pMultisampleState = &multisampling;
		pipelineInfo.pDepthStencilState = null; // Optional
		pipelineInfo.pColorBlendState = &colorBlending;
		pipelineInfo.pDynamicState = null; // Optional
		pipelineInfo.layout = pipelineLayout;
		pipelineInfo.renderPass = renderPass;
		pipelineInfo.subpass = 0;

		@static TracyLoc zone5 = TracyLoc(null, "vkCreatePipelineLayout", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
		if (vkCreateGraphicsPipelines(device, null, 1, &pipelineInfo, null, &graphicsPipeline) != VK_SUCCESS) {
			println("failed to create graphics pipeline!");
			isRunning = false;
		}
		tracy_emit_zone_end(ctx5);

		tracy_emit_zone_end(ctx);
	}

	void createFramebuffers() {
		@static TracyLoc zone = TracyLoc(null, "Client.createFramebuffers", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		swapChainFramebuffers = resizeArray[VkFramebuffer](swapChainFramebuffers, swapChainImageViews.length);

		for (u64 i = 0; i < swapChainImageViews.length; i++) {
			VkImageView[1] attachments;
			attachments[0] = swapChainImageViews[i];

			VkFramebufferCreateInfo framebufferInfo;
			framebufferInfo.renderPass = renderPass;
			framebufferInfo.attachmentCount = cast(u32)attachments.length;
			framebufferInfo.pAttachments = attachments.ptr;
			framebufferInfo.width = swapChainExtent.width;
			framebufferInfo.height = swapChainExtent.height;
			framebufferInfo.layers = 1;

			if (vkCreateFramebuffer(device, &framebufferInfo, null, &swapChainFramebuffers[i]) != VK_SUCCESS) {
				println("failed to create framebuffer!");
				isRunning = false;
			}
		}

		tracy_emit_zone_end(ctx);
	}

	void createCommandPool() {
		@static TracyLoc zone = TracyLoc(null, "Client.createCommandPool", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

		VkCommandPoolCreateInfo poolInfo;
		poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
		poolInfo.queueFamilyIndex = queueFamilyIndices.indices[QueueFamily.graphics];

		if (vkCreateCommandPool(device, &poolInfo, null, &commandPool) != VK_SUCCESS) {
			println("failed to create command pool!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);
	}

	void createVertexBuffer() {
		@static TracyLoc zone = TracyLoc(null, "Client.createVertexBuffer", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkDeviceSize bufferSize = vertices.sizeof;

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;

		createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &stagingBuffer, &stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
			memcpy(data, vertices.ptr, bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &vertexBuffer, &vertexBufferMemory);

		copyBuffer(stagingBuffer, vertexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, null);
		vkFreeMemory(device, stagingBufferMemory, null);

		tracy_emit_zone_end(ctx);
	}

	void createIndexBuffer() {
		VkDeviceSize bufferSize = indicies.sizeof;

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;

		createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &stagingBuffer, &stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
		memcpy(data, indicies.ptr, bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &indexBuffer, &indexBufferMemory);

		copyBuffer(stagingBuffer, indexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, null);
		vkFreeMemory(device, stagingBufferMemory, null);
	}

	void createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer* buffer, VkDeviceMemory* bufferMemory) {
		@static TracyLoc zone = TracyLoc(null, "Client.createBuffer", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkBufferCreateInfo bufferInfo;
		bufferInfo.size = size;
		bufferInfo.usage = usage;
		bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

		if (vkCreateBuffer(device, &bufferInfo, null, buffer) != VK_SUCCESS) {
			println("failed to create buffer!");
			isRunning = false;
			return;
		}

		VkMemoryRequirements memRequirements;
		vkGetBufferMemoryRequirements(device, *buffer, &memRequirements);

		VkMemoryAllocateInfo allocInfo;
		allocInfo.allocationSize = memRequirements.size;
		allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

		if (vkAllocateMemory(device, &allocInfo, null, bufferMemory) != VK_SUCCESS) {
			println("failed to allocate buffer memory!");
			isRunning = false;
			return;
		}

		vkBindBufferMemory(device, *buffer, *bufferMemory, 0);

		tracy_emit_zone_end(ctx);
	}

	void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
		VkCommandBufferAllocateInfo allocInfo;
		allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocInfo.commandPool = commandPool;
		allocInfo.commandBufferCount = 1;

		VkCommandBuffer commandBuffer;
		vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer);

		VkCommandBufferBeginInfo beginInfo;
		beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

		vkBeginCommandBuffer(commandBuffer, &beginInfo);

		VkBufferCopy copyRegion;
		copyRegion.srcOffset = 0; // Optional
		copyRegion.dstOffset = 0; // Optional
		copyRegion.size = size;
		vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

		vkEndCommandBuffer(commandBuffer);

		VkSubmitInfo submitInfo;
		submitInfo.commandBufferCount = 1;
		submitInfo.pCommandBuffers = &commandBuffer;

		vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
		vkQueueWaitIdle(graphicsQueue);

		vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
	}

	u32 findMemoryType(u32 typeFilter, VkMemoryPropertyFlags properties) {
		VkPhysicalDeviceMemoryProperties memProperties;
		vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);

		for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
			if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
				return i;
			}
		}

		println("failed to find suitable memory type!");
		isRunning = false;
		return 0;
	}

	void createCommandBuffers() {
		@static TracyLoc zone = TracyLoc(null, "Client.createCommandBuffers", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		commandBuffers = resizeArray[VkCommandBuffer](commandBuffers, MAX_FRAMES_IN_FLIGHT);

		VkCommandBufferAllocateInfo allocInfo;
		allocInfo.commandPool = commandPool;
		allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocInfo.commandBufferCount = cast(u32)commandBuffers.length;

		if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.ptr) != VK_SUCCESS) {
			println("failed to allocate command buffers!");
			isRunning = false;
			tracy_emit_zone_end(ctx);
			return;
		}

		tracy_emit_zone_end(ctx);
	}

	void recordCommandBuffer(VkCommandBuffer commandBuffer, u32 imageIndex) {
		@static TracyLoc zone = TracyLoc(null, "Client.recordCommandBuffer", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkCommandBufferBeginInfo beginInfo;

		if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
			println("failed to begin recording command buffer!");
			isRunning = false;
		}

		VkRenderPassBeginInfo renderPassInfo;
		renderPassInfo.renderPass = renderPass;
		renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];
		renderPassInfo.renderArea.offset = VkOffset2D(0, 0);
		renderPassInfo.renderArea.extent = swapChainExtent;

		VkClearValue clearColor;
		clearColor.color.float32[0] = 0.0;
		clearColor.color.float32[1] = 0.0;
		clearColor.color.float32[2] = 0.0;
		clearColor.color.float32[3] = 1.0;
		renderPassInfo.clearValueCount = 1;
		renderPassInfo.pClearValues = &clearColor;

		vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);

			vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

			VkDeviceSize offset = 0;
			vkCmdBindVertexBuffers(commandBuffer, 0, 1, &vertexBuffer, &offset);

			vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT16);

			vkCmdDrawIndexed(commandBuffer, cast(u32)indicies.length, 1, 0, 0, 0);

		vkCmdEndRenderPass(commandBuffer);

		if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
			println("failed to record command buffer!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);
	}

	void createSyncObjects() {
		@static TracyLoc zone = TracyLoc(null, "Client.createSyncObjects", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		imageAvailableSemaphores = resizeArray[VkSemaphore](imageAvailableSemaphores, MAX_FRAMES_IN_FLIGHT);
		renderFinishedSemaphores = resizeArray[VkSemaphore](renderFinishedSemaphores, MAX_FRAMES_IN_FLIGHT);
		inFlightFences = resizeArray[VkFence](inFlightFences, MAX_FRAMES_IN_FLIGHT);

		VkSemaphoreCreateInfo semaphoreInfo;

		VkFenceCreateInfo fenceInfo;
		fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

		for (u64 i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			if (vkCreateSemaphore(device, &semaphoreInfo, null, &imageAvailableSemaphores[i]) != VK_SUCCESS ||
				vkCreateSemaphore(device, &semaphoreInfo, null, &renderFinishedSemaphores[i]) != VK_SUCCESS ||
				vkCreateFence(device, &fenceInfo, null, &inFlightFences[i]) != VK_SUCCESS) {
				println("failed to create synchronization objects for a frame!");
				isRunning = false;
			}
		}

		tracy_emit_zone_end(ctx);
	}

	void drawFrame() {
		@static TracyLoc zone = TracyLoc(null, "Client.drawFrame", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static TracyLoc zone1 = TracyLoc(null, "vkWaitForFences", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, u64.max);
		tracy_emit_zone_end(ctx1);

		u32 imageIndex;
		@static TracyLoc zone2 = TracyLoc(null, "vkAcquireNextImageKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		VkResult result = vkAcquireNextImageKHR(device, swapChain, u64.max, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);
		if (result == VK_ERROR_OUT_OF_DATE_KHR) {
			recreateSwapChain();
			return;
		} else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
			println("failed to acquire swap chain image!");
			isRunning = false;
			return;
		}
		tracy_emit_zone_end(ctx2);

		@static TracyLoc zone4 = TracyLoc(null, "vkResetFences", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		vkResetFences(device, 1, &inFlightFences[currentFrame]);
		tracy_emit_zone_end(ctx4);

		vkResetCommandBuffer(commandBuffers[currentFrame], /*VkCommandBufferResetFlagBits*/ 0);
		recordCommandBuffer(commandBuffers[currentFrame], imageIndex);

		VkSubmitInfo submitInfo;

		VkSemaphore waitSemaphore = imageAvailableSemaphores[currentFrame];
		VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		submitInfo.waitSemaphoreCount = 1;
		submitInfo.pWaitSemaphores = &waitSemaphore;
		submitInfo.pWaitDstStageMask = &waitStage;

		submitInfo.commandBufferCount = 1;
		submitInfo.pCommandBuffers = &commandBuffers[currentFrame];

		VkSemaphore signalSemaphore = renderFinishedSemaphores[currentFrame];
		submitInfo.signalSemaphoreCount = 1;
		submitInfo.pSignalSemaphores = &signalSemaphore;

		@static TracyLoc zone5 = TracyLoc(null, "vkQueueSubmit", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
		if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
			println("failed to submit draw command buffer!");
			isRunning = false;
			return;
		}
		tracy_emit_zone_end(ctx5);

		VkPresentInfoKHR presentInfo;

		presentInfo.waitSemaphoreCount = 1;
		presentInfo.pWaitSemaphores = &signalSemaphore;

		presentInfo.swapchainCount = 1;
		presentInfo.pSwapchains = &swapChain;

		presentInfo.pImageIndices = &imageIndex;

		@static TracyLoc zone6 = TracyLoc(null, "vkQueuePresentKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx6 = tracy_emit_zone_begin(&zone6, TRACY_ON);
		result = vkQueuePresentKHR(presentQueue, &presentInfo);
		tracy_emit_zone_end(ctx6);

		if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) {
			//println("recreateSwapChain ", result == VK_ERROR_OUT_OF_DATE_KHR, " ", result == VK_SUBOPTIMAL_KHR, " ", framebufferResized);
			recreateSwapChain();
		} else if (result != VK_SUCCESS) {
			println("failed to present swap chain image!");
			isRunning = false;
			return;
		}

		currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;

		tracy_emit_zone_end(ctx);
	}

	u8[] compileShader(shaderc_compiler_t compiler, u8[] source, u8[] filename, u8* entryname, shaderc_shader_kind shader_kind) {
		@static TracyLoc zone = TracyLoc(null, "Client.compileShader", "main.vx", cast(u32)__LINE__, 0xAAAA00); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static TracyLoc zone1 = TracyLoc(null, "shaderc_compile_into_spv", "main.vx", cast(u32)__LINE__, 0xAAAA00); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		shaderc_compilation_result_t result = shaderc_compile_into_spv(
			compiler, source.ptr, source.length,
			shader_kind, filename.ptr, entryname, null);
		tracy_emit_zone_end(ctx1);

		u64 numWarnings = shaderc_result_get_num_warnings(result);
		u64 numErrors = shaderc_result_get_num_errors(result);

		shaderc_compilation_status status = shaderc_result_get_compilation_status(result);

		println("Compiled `", filename, "` with ", numWarnings, " warnings, ", numErrors, " errors, status: ", cast(u32)status);

		if (numWarnings != 0 || numErrors != 0) {
			u8* msg = shaderc_result_get_error_message(result);
			print(msg.fromStringz);
		}

		u64 resLength = shaderc_result_get_length(result);
		u8* ptr = shaderc_result_get_bytes(result);
		u8[] code = makeVoidArray[u8](resLength);
		memcopy(code, ptr[0..resLength]);

		shaderc_result_release(result);

		tracy_emit_zone_end(ctx);

		return code;
	}

	VkShaderModule createShaderModule(u8[] code) {
		@static TracyLoc zone = TracyLoc(null, "Client.createShaderModule", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkShaderModuleCreateInfo createInfo;
		createInfo.codeSize = code.length; // size is in bytes
		createInfo.pCode = cast(u32*)code.ptr;

		VkShaderModule shaderModule;
		if (vkCreateShaderModule(device, &createInfo, null, &shaderModule) != VK_SUCCESS) {
			println("failed to create shader module!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);

		return shaderModule;
	}

	VkSurfaceFormatKHR chooseSwapSurfaceFormat(Array[VkSurfaceFormatKHR] availableFormats) {
		@static TracyLoc zone = TracyLoc(null, "Client.chooseSwapSurfaceFormat", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		for (u32 i = 0; i < availableFormats.length; ++i) {
			VkSurfaceFormatKHR availableFormat = availableFormats.ptr[i];
			if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
				tracy_emit_zone_end(ctx);
				return availableFormat;
			}
		}

		tracy_emit_zone_end(ctx);

		return availableFormats.ptr[0];
	}

	VkPresentModeKHR chooseSwapPresentMode(Array[VkPresentModeKHR] availablePresentModes) {
		@static TracyLoc zone = TracyLoc(null, "Client.chooseSwapPresentMode", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		for (u32 i = 0; i < availablePresentModes.length; ++i) {
			VkPresentModeKHR availablePresentMode = availablePresentModes.ptr[i];
			if (availablePresentMode == PRESENT_MODE) {
				tracy_emit_zone_end(ctx);
				return availablePresentMode;
			}
		}

		tracy_emit_zone_end(ctx);

		return VK_PRESENT_MODE_FIFO_KHR;
	}

	VkExtent2D chooseSwapExtent(VkSurfaceCapabilitiesKHR capabilities) {
		@static TracyLoc zone = TracyLoc(null, "Client.chooseSwapExtent", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (capabilities.currentExtent.width != u32.max) {
			tracy_emit_zone_end(ctx);
			return capabilities.currentExtent;
		} else {
			i32 width;
			i32 height;
			glfwGetFramebufferSize(window, &width, &height);

			VkExtent2D actualExtent = VkExtent2D(cast(u32)width, cast(u32)height);

			actualExtent.width = clamp[u32](actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
			actualExtent.height = clamp[u32](actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

			tracy_emit_zone_end(ctx);
			return actualExtent;
		}
	}

	void querySwapChainSupport(VkPhysicalDevice device, SwapChainSupportDetails* result) {
		@static TracyLoc zone = TracyLoc(null, "Client.querySwapChainSupport", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static TracyLoc zone1 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &result.capabilities);
		tracy_emit_zone_end(ctx1);

		u32 formatCount;
		@static TracyLoc zone2 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceFormatsKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, null);
		tracy_emit_zone_end(ctx2);

		if (formatCount) {
			VkSurfaceFormatKHR* ptr = result.formats.putVoid(formatCount);
			@static TracyLoc zone3 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceFormatsKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
			vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, ptr);
			tracy_emit_zone_end(ctx3);
		}

		u32 presentModeCount;
		@static TracyLoc zone4 = TracyLoc(null, "vkGetPhysicalDeviceSurfacePresentModesKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, null);
		tracy_emit_zone_end(ctx4);

		if (presentModeCount != 0) {
			@static TracyLoc zone4 = TracyLoc(null, "result.presentModes.putVoid", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
			VkPresentModeKHR* ptr = result.presentModes.putVoid(presentModeCount);
			tracy_emit_zone_end(ctx4);
			@static TracyLoc zone5 = TracyLoc(null, "vkGetPhysicalDeviceSurfacePresentModesKHR", "main.vx", cast(u32)__LINE__, 0x000000); TracyZoneCtx ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
			vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, ptr);
			tracy_emit_zone_end(ctx5);
		}

		tracy_emit_zone_end(ctx);
	}

	void onKey(i32 key, i32 scancode, i32 action, i32 mods)
	{
		println("onKey key:", key, " scancode:", scancode, " action:", action, " mods:", mods);
	}

	void onFramebufferResize(i32 width, i32 height)
	{
		//println("Resized to ", width, " ", height);
		framebufferResized = true;
	}
}

struct QueueFamilyIndices {
	enum u32 NUM_FAMILIES = 2;

	QueueFamilyFlags presentFamilies; // specifies which families have valid index
	u32[NUM_FAMILIES] indices;


	bool isComplete() #inline {
		enum requiredFamilies = QueueFamilyFlags.graphics | QueueFamilyFlags.present;
		return (presentFamilies & requiredFamilies) == requiredFamilies;
	}
}

enum QueueFamily : u32 {
	graphics = 0,
	present  = 1,
}
enum QueueFamilyFlags : u32 {
	graphics = 0b0000_0001,
	present  = 0b0000_0010,
}

u32 debugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
	void* pUserData) {

	println("validation layer: ", pCallbackData.pMessage.fromStringz);

	return VK_FALSE;
}

bool checkLayers(u8*[] requestedLayers, VkLayerProperties[] availableLayers)
{
	for (i32 i; i < requestedLayers.length; ++i) {
		u8[] requestedLayer = requestedLayers[i].fromStringz;
		//println("req ", requestedLayer);
		bool layerFound = false;
		for (i32 j; j < availableLayers.length; ++j) {
			u8[] name = availableLayers[j].layerName.ptr.fromStringz;
			//println("  ", name, " ", availableLayers[j].specVersion, " ", availableLayers[j].implementationVersion, " ", availableLayers[j].description.ptr.fromStringz);
			if (equal[u8[]](name, requestedLayer)) {
				layerFound = true;
				break;
			}
		}
		if (!layerFound) {
			return false;
		}
	}
	return true;
}

bool checkExtensions(u8*[] requestedExtensions, VkExtensionProperties[] availableExtensions)
{
	for (i32 i; i < requestedExtensions.length; ++i) {
		u8[] requestedExtension = requestedExtensions[i].fromStringz;
		bool extensionFound = false;
		for (i32 j; j < availableExtensions.length; ++j) {
			u8[] name = availableExtensions[j].extensionName.ptr.fromStringz;
			if (equal[u8[]](name, requestedExtension)) {
				extensionFound = true;
				break;
			}
		}
		if (!extensionFound) {
			return false;
		}
	}
	return true;
}

struct Vertex
{
	vec2 pos;
	vec3 color;

	@static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription;
		bindingDescription.binding = 0;
		bindingDescription.stride = cast(u32)Vertex.sizeof;
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

		return bindingDescription;
	}

	@static VkVertexInputAttributeDescription[2] getAttributeDescriptions() {
		VkVertexInputAttributeDescription[2] attributeDescriptions;

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
		attributeDescriptions[0].offset = cast(u32)Vertex.pos.offsetof;

		attributeDescriptions[1].binding = 0;
		attributeDescriptions[1].location = 1;
		attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[1].offset = cast(u32)Vertex.color.offsetof;

		return attributeDescriptions;
	}
}
