/// Copyright: Copyright (c) 2021-2022 Andrey Penechko.
/// License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).
/// Authors: Andrey Penechko.
module hello_triangle.main;

import core.enet;
import core.glfw3;
import core.host;
import core.kernel32;
import core.math;
import core.mdbx;
import core.mimalloc;
import core.qoi;
import core.shaderc;
import core.tracy;
import core.utils;
import core.vector;
import core.vulkan.functions;
import core.vulkan.types;
import core.vulkan.vma;


void main()
{
	__init_utils();

	Client client;
	client.run();
}

enum TRACY_ON = 1;

struct SwapchainSupportDetails {
	VkSurfaceCapabilitiesKHR  capabilities;
	Array[VkSurfaceFormatKHR] formats;
	Array[VkPresentModeKHR]   presentModes;

	void free() {
		formats.free();
		presentModes.free();
	}
}

struct VkContext {
	VkInstance instance;
	VkPhysicalDevice physicalDevice;
	SwapchainSupportDetails swapchainSupport; // result of querySwapChainSupport on physicalDevice
	VkDevice device; // logical device

	VkPhysicalDeviceMemoryProperties memProperties; // cached

	VkQueue graphicsQueue;
	VkQueue presentQueue;

	VkCommandPool commandPool;
	VkDescriptorPool descriptorPool;

	VkFence uploadFence;
	VkCommandBuffer uploadCommandBuffer;

	enum u32 NUM_FRAMES = 2;
	u32 frameIndex; // 0, 1
	Swapchain swapchain;
	FrameData[NUM_FRAMES] frames;

	VmaAllocator vkallocator;
}

struct SwapchainImage {
	VkImage image;
	VkImageView imageView;
	VkFramebuffer framebuffer;
}

struct Swapchain {
	enum u32 MAX_IMAGES = 3; // We support from 1 to 3 images

	u32 numImages; // Returned by vkGetSwapchainImagesKHR [1; MAX_IMAGES]
	u32 imageIndex; // (0 <= imageIndex < numImages)

	VkSwapchainKHR swapchain;
	VkSurfaceKHR   surface;
	VkFormat       swapchainImageFormat;
	VkExtent2D     swapchainExtent;
	VkRenderPass   renderPass;

	SwapchainImage[MAX_IMAGES] images;
}

struct FrameData {
	VkSemaphore imageAvailableSemaphore;
	VkSemaphore renderFinishedSemaphore;
	VkFence     inFlightFence;

	VkCommandBuffer commandBuffer;
	VkDescriptorSet descriptorSet;

	BarBuffer vertexBuffer;
	BarBuffer indexBuffer;
	BarBuffer uniformBuffer;
}

struct Pipeline {
	VkDescriptorSetLayout descriptorSetLayout;
	VkPipelineLayout pipelineLayout;
	VkPipeline graphicsPipeline;
}

// Single buffer for single frame stored in BAR memory
struct BarBuffer {
	VkDeviceSize        size;
	VkBuffer          buffer;
	VmaAllocation allocation;
}

// 4 channels
struct ImageData {
	u8* ptr;
	u32 width;
	u32 height;

	u32 byteLength() { return width * height * 4; }
}

struct Client
{
	void run()
	{
		if (init()) return;
		mainLoop();
		free();
	}


	GLFWwindow* window;
	MDBX_env* mdbxEnv;

	VkContext vkcontext;

	VkDebugUtilsMessengerEXT debugMessenger;

	VkShaderModule vertShaderModule;
	VkShaderModule fragShaderModule;

	Pipeline pipeline;

	bool framebufferResized = false;

	enum WIDTH = 800;
	enum HEIGHT = 600;

	//enum PRESENT_MODE = VK_PRESENT_MODE_IMMEDIATE_KHR;
	enum PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR;
	//enum PRESENT_MODE = VK_PRESENT_MODE_FIFO_KHR;
	//enum PRESENT_MODE = VK_PRESENT_MODE_FIFO_RELAXED_KHR;

	bool enableValidationLayers = true;
	u8*[1] validationLayers;
	u8*[1] deviceExtensions;

	Array[Vertex] vertices;
	Array[u16] indicies;
	ImageData fontImage;

	bool isRunning = true;

	void putQuadAt(vec3 pos) {
		u16 ind = cast(u16)vertices.length;

		Vertex* v = vertices.putVoid(4);
		u16* i = indicies.putVoid(6);

		v[0] = Vertex(add_vec3(vec3(-0.1, -0.1, 0), pos), Color(255,   0,   0));
		v[1] = Vertex(add_vec3(vec3( 0.1, -0.1, 0), pos), Color(  0, 255,   0));
		v[2] = Vertex(add_vec3(vec3( 0.1,  0.1, 0), pos), Color(  0,   0, 255));
		v[3] = Vertex(add_vec3(vec3(-0.1,  0.1, 0), pos), Color(255, 255, 255));
		i[0] = ind + 0;
		i[1] = ind + 1;
		i[2] = ind + 2;
		i[3] = ind + 2;
		i[4] = ind + 3;
		i[5] = ind + 0;
	}

	Status init()
	{
		@static auto zone = TracyLoc(null, "Client.init", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		putQuadAt(vec3(0,0,0));

		validationLayers[0] = "VK_LAYER_KHRONOS_validation";
		deviceExtensions[0] = "VK_KHR_swapchain";

		if (initWindow() != OK) return Status.ERR;
		if (initVulkan() != OK) return Status.ERR;

		@static auto zone1 = TracyLoc(null, "enet_initialize", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		enet_initialize();
		tracy_emit_zone_end(ctx1);

		u8[] path = "test.db";
		@static auto zone2 = TracyLoc(null, "mdbx_env_create", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		mdbx_env_create(&mdbxEnv);
		tracy_emit_zone_end(ctx2);
		@static auto zone3 = TracyLoc(null, "mdbx_env_open", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
		mdbx_env_open(
			mdbxEnv,
			path.ptr,
			MDBX_env_flags_t.MDBX_NOSUBDIR |
			MDBX_env_flags_t.MDBX_EXCLUSIVE,
			//rwx_rwx_rwx
			0b110_110_110);
		tracy_emit_zone_end(ctx3);

		tracy_emit_zone_end(ctx);

		return Status.OK;
	}

	Status initWindow()
	{
		@static auto zone1 = TracyLoc(null, "Client.initWindow", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone1, TRACY_ON);

		@static auto zone2 = TracyLoc(null, "glfwInit", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwInit = tracy_emit_zone_begin(&zone2, TRACY_ON);
		if (!glfwInit()) {
			println("GLFW init failed");
			tracy_emit_zone_end(ctx_glfwInit);
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx_glfwInit);

		// Do not create OpenGL context
		@static auto zone3 = TracyLoc(null, "glfwWindowHint", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwWindowHint = tracy_emit_zone_begin(&zone3, TRACY_ON);
		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
		tracy_emit_zone_end(ctx_glfwWindowHint);

		@static auto zone4 = TracyLoc(null, "glfwCreateWindow", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwCreateWindow = tracy_emit_zone_begin(&zone4, TRACY_ON);
		window = glfwCreateWindow(WIDTH, HEIGHT, "Voxelman - Vulkan Tutorial - Uniform buffers", null, null);
		tracy_emit_zone_end(ctx_glfwCreateWindow);

		@static auto zone5 = TracyLoc(null, "glfwSetWindowUserPointer", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwSetWindowUserPointer = tracy_emit_zone_begin(&zone5, TRACY_ON);
		glfwSetWindowUserPointer(window, this);
		tracy_emit_zone_end(ctx_glfwSetWindowUserPointer);

		@static auto zone6 = TracyLoc(null, "glfwSetKeyCallback", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwSetKeyCallback = tracy_emit_zone_begin(&zone6, TRACY_ON);
		glfwSetKeyCallback(window, &glfw_key_callback);
		glfwSetMouseButtonCallback(window, &glfw_mouse_button_callback);
		tracy_emit_zone_end(ctx_glfwSetKeyCallback);

		@static auto zone7 = TracyLoc(null, "glfwSetFramebufferSizeCallback", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_glfwSetFBCallback = tracy_emit_zone_begin(&zone7, TRACY_ON);
		glfwSetFramebufferSizeCallback(window, &glfw_framebuffer_resize_callback);
		tracy_emit_zone_end(ctx_glfwSetFBCallback);

		tracy_emit_zone_end(ctx);

		return Status.OK;
	}

	@static void glfw_key_callback(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods)
	{
		Client* client = cast(Client*)glfwGetWindowUserPointer(window);
		client.onKey(key, scancode, action, mods);
	}

	@static void glfw_mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
	{
		Client* client = cast(Client*)glfwGetWindowUserPointer(window);
		f64 xpos;
		f64 ypos;
		glfwGetCursorPos(window, &xpos, &ypos);
		i32 width;
		i32 height;
		glfwGetFramebufferSize(window, &width, &height);
		if (width == 0 || height == 0) return;
		f32 x = cast(f32)xpos/width;
		f32 y = cast(f32)ypos/height;
		client.onMouseClick(button, action, mods, x, y);
	}

	@static void glfw_framebuffer_resize_callback(GLFWwindow* window, i32 width, i32 height)
	{
		Client* client = cast(Client*)glfwGetWindowUserPointer(window);
		client.onFramebufferResize(width, height);
	}

	Status initVulkan()
	{
		@static auto zone = TracyLoc(null, "Client.initVulkan", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (!glfwVulkanSupported) {
			println("Vulkan is not supported");
			return Status.ERR;
		}

		auto vkGetInstanceProcAddr = cast(PFN_vkGetInstanceProcAddr)glfwGetInstanceProcAddress(null, "vkGetInstanceProcAddr");
		loadGlobalLevelFunctions(vkGetInstanceProcAddr);

		if (createInstance() != OK) return Status.ERR;
		if (setupDebugMessenger() != OK) return Status.ERR;
		if (createSurface() != OK) return Status.ERR;
		if (pickPhysicalDevice() != OK) return Status.ERR;
		if (createLogicalDevice() != OK) return Status.ERR;
		if (createAllocator(vkGetInstanceProcAddr) != OK) return Status.ERR;
		if (createSyncObjects() != OK) return Status.ERR;
		if (createSwapChain(null) != OK) return Status.ERR;
		if (createImageViews() != OK) return Status.ERR;
		if (createRenderPass() != OK) return Status.ERR;
		if (loadShaders() != OK) return Status.ERR;
		if (createDescriptorSetLayout() != OK) return Status.ERR;
		if (createGraphicsPipeline() != OK) return Status.ERR;
		if (createFramebuffers() != OK) return Status.ERR;
		if (createCommandPool() != OK) return Status.ERR;
		if (createCommandBuffers() != OK) return Status.ERR;
		if (createTextureImage() != OK) return Status.ERR;
		if (createUniformBuffers() != OK) return Status.ERR;
		if (createDescriptorPool() != OK) return Status.ERR;
		if (createDescriptorSets() != OK) return Status.ERR;

		tracy_emit_zone_end(ctx);

		return Status.OK;
	}

	void mainLoop()
	{
		while(isRunning && !glfwWindowShouldClose(window)) {
			f64 time = glfwGetTime();
			update();
			Status err = drawFrame(cast(f32)time);
			if (err) isRunning = false;
			tracy_emit_frame_mark();
		}

		vkDeviceWaitIdle(vkcontext.device);
	}

	void update()
	{
		@static auto zone_loc1 = TracyLoc(null, "glfwPollEvents", "main.vx", cast(u32)__LINE__, 0x00AA00); TracyZoneCtx tracy_ctx1 = tracy_emit_zone_begin(&zone_loc1, TRACY_ON);
		glfwPollEvents();
		tracy_emit_zone_end(tracy_ctx1);
	}

	void free()
	{
		@static auto zone = TracyLoc(null, "Client.free", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		mdbx_env_close_ex(mdbxEnv);
		enet_deinitialize();
		freeVulkan();
		freeWindow();

		tracy_emit_zone_end(ctx);
	}

	void freeVulkan()
	{
		@static auto zone = TracyLoc(null, "Client.freeVulkan", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		vkcontext.swapchainSupport.free();

		vkDestroyShaderModule(vkcontext.device, vertShaderModule, null);
		vkDestroyShaderModule(vkcontext.device, fragShaderModule, null);

		cleanupSwapChain();
		vkDestroySwapchainKHR(vkcontext.device, vkcontext.swapchain.swapchain, null);

		vkDestroyDescriptorPool(vkcontext.device, vkcontext.descriptorPool, null);
		vkDestroyDescriptorSetLayout(vkcontext.device, pipeline.descriptorSetLayout, null);

		for (u64 i = 0; i < vkcontext.NUM_FRAMES; ++i) {
			auto frame = &vkcontext.frames[i];
			vkDestroySemaphore(vkcontext.device, vkcontext.frames[i].renderFinishedSemaphore, null);
			vkDestroySemaphore(vkcontext.device, vkcontext.frames[i].imageAvailableSemaphore, null);
			vkDestroyFence(vkcontext.device, vkcontext.frames[i].inFlightFence, null);

			freeBarBuffer(&frame.vertexBuffer);
			freeBarBuffer(&frame.indexBuffer);
			freeBarBuffer(&frame.uniformBuffer);
		}

		vkDestroyFence(vkcontext.device, vkcontext.uploadFence, null);

		vkDestroyCommandPool(vkcontext.device, vkcontext.commandPool, null);

		// all allocated memory must be freed before the deleting allocator
		vmaDestroyAllocator(vkcontext.vkallocator);

		vkDestroyDevice(vkcontext.device, null);

		if (enableValidationLayers) {
			vkDestroyDebugUtilsMessengerEXT(vkcontext.instance, debugMessenger, null);
		}

		vkDestroySurfaceKHR(vkcontext.instance, vkcontext.swapchain.surface, null);
		vkDestroyInstance(vkcontext.instance, null);

		tracy_emit_zone_end(ctx);
	}

	void freeWindow()
	{
		@static auto zone = TracyLoc(null, "Client.freeWindow", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		glfwDestroyWindow(window);
		glfwTerminate();

		tracy_emit_zone_end(ctx);
	}

	void cleanupSwapChain() {
		for (u64 i = 0; i < vkcontext.swapchain.numImages; ++i) {
			vkDestroyFramebuffer(vkcontext.device, vkcontext.swapchain.images[i].framebuffer, null);
			vkcontext.swapchain.images[i].framebuffer = null;
			vkDestroyImageView(vkcontext.device, vkcontext.swapchain.images[i].imageView, null);
			vkcontext.swapchain.images[i].imageView = null;
		}

		vkDestroyPipeline(vkcontext.device, pipeline.graphicsPipeline, null);
		pipeline.graphicsPipeline = null;
		vkDestroyPipelineLayout(vkcontext.device, pipeline.pipelineLayout, null);
		pipeline.pipelineLayout = null;
		vkDestroyRenderPass(vkcontext.device, vkcontext.swapchain.renderPass, null);
		vkcontext.swapchain.renderPass = null;
	}

	Status recreateSwapChain() {
		@static auto zone = TracyLoc(null, "Client.recreateSwapChain", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		// Pause if window was minimized
		i32 width;
		i32 height;
		glfwGetFramebufferSize(window, &width, &height);
		while (width == 0 || height == 0) {
			glfwGetFramebufferSize(window, &width, &height);
			glfwWaitEvents();
		}

		framebufferResized = false;

		vkDeviceWaitIdle(vkcontext.device);

		VkSwapchainKHR oldSwapchain = vkcontext.swapchain.swapchain;
		vkcontext.swapchain.swapchain = null;

		cleanupSwapChain();

		querySwapChainSupport(vkcontext.physicalDevice, &vkcontext.swapchainSupport);

		createSwapChain(oldSwapchain);

		if (oldSwapchain)
			vkDestroySwapchainKHR(vkcontext.device, oldSwapchain, null);

		if (createImageViews() != OK) return Status.ERR;
		if (createRenderPass() != OK) return Status.ERR;
		if (createGraphicsPipeline() != OK) return Status.ERR;
		if (createFramebuffers() != OK) return Status.ERR;

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createInstance()
	{
		@static auto zone = TracyLoc(null, "Client.createInstance", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkApplicationInfo appInfo;
		appInfo.pApplicationName = "Hello Triangle";
		appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
		appInfo.pEngineName = "Voxelman";
		appInfo.engineVersion = VK_MAKE_VERSION(2, 0, 0);
		appInfo.apiVersion = VK_API_VERSION_1_0;

		VkInstanceCreateInfo createInfo;
		createInfo.pApplicationInfo = &appInfo;

		Array[u8*] extensions = getRequiredExtensions;

		//println("Requesting ", extensions.length, " extensions:");
		//for (i32 i; i < extensions.length; ++i) {
		//	println("  ", extensions.ptr[i].fromStringz);
		//}

		createInfo.enabledExtensionCount = extensions.length;
		createInfo.ppEnabledExtensionNames = extensions.ptr;

		VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
		if (enableValidationLayers) {
			if (!checkValidationLayerSupport()) {
				println("Validation layers requested, but not available!");
			} else {
				createInfo.enabledLayerCount = cast(u32)validationLayers.length;
				createInfo.ppEnabledLayerNames = validationLayers.ptr;

				populateDebugMessengerCreateInfo(&debugCreateInfo);
				createInfo.pNext = &debugCreateInfo;
			}
		} else {
			createInfo.enabledLayerCount = 0;
		}

		//println("vkCreateInstance ", cast(void*)vkCreateInstance, " ", cast(void*)&createInfo, " ", cast(void*)&appInfo);

		@static auto zone1 = TracyLoc(null, "vkCreateInstance", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		i32 vkCreateInstanceResult = cast(i32)vkCreateInstance(&createInfo, null, &vkcontext.instance);
		tracy_emit_zone_end(ctx1);

		if (vkCreateInstanceResult != VK_SUCCESS) {
			println("vkCreateInstance failed: ", vkCreateInstanceResult);
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}
		//println("VkInstance ", cast(void*)instance);

		@static auto zone2 = TracyLoc(null, "loadInstanceLevelFunctions", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		loadInstanceLevelFunctions(vkcontext.instance);
		tracy_emit_zone_end(ctx2);

		//{
		//	u32 extensionCount;
		//	vkEnumerateInstanceExtensionProperties(null, &extensionCount, null);
		//	println("\n", extensionCount, " instance extensions supported");
		//	auto extensions = makeArray[VkExtensionProperties](extensionCount);
		//	vkEnumerateInstanceExtensionProperties(null, &extensionCount, extensions.ptr);
		//	for (i32 i; i < extensionCount; ++i) {
		//		println("  ", extensions[i].extensionName.ptr.fromStringz, " ", extensions[i].specVersion);
		//	}
		//	freeArray[VkExtensionProperties](extensions);
		//}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT* createInfo) {
		createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
		//createInfo.messageSeverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
		createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
		createInfo.pfnUserCallback = &debugCallback;
		createInfo.pUserData = null; // Optional
	}

	Status createAllocator(PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr)
	{
		VmaVulkanFunctions vulkanFunctions;
		vulkanFunctions.vkGetInstanceProcAddr = vkGetInstanceProcAddr;
		vulkanFunctions.vkGetDeviceProcAddr = vkGetDeviceProcAddr;

		VmaAllocatorCreateInfo allocatorCreateInfo;
		allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_0;
		allocatorCreateInfo.physicalDevice = vkcontext.physicalDevice;
		allocatorCreateInfo.device = vkcontext.device;
		allocatorCreateInfo.instance = vkcontext.instance;
		allocatorCreateInfo.pVulkanFunctions = &vulkanFunctions;

		vmaCreateAllocator(&allocatorCreateInfo, &vkcontext.vkallocator);
		return Status.OK;
	}

	Status setupDebugMessenger() {
		@static auto zone = TracyLoc(null, "Client.setupDebugMessenger", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (!enableValidationLayers) {
			tracy_emit_zone_end(ctx);
			return Status.OK;
		}

		VkDebugUtilsMessengerCreateInfoEXT createInfo;
		populateDebugMessengerCreateInfo(&createInfo);

		if (vkCreateDebugUtilsMessengerEXT(vkcontext.instance, &createInfo, null, &debugMessenger) != VK_SUCCESS) {
			println("failed to set up debug messenger!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createSurface() {
		@static auto zone = TracyLoc(null, "Client.createSurface", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (glfwCreateWindowSurface(vkcontext.instance, window, null, &vkcontext.swapchain.surface) != VK_SUCCESS) {
			println("failed to create window surface!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	bool checkValidationLayerSupport() {
		@static auto zone = TracyLoc(null, "Client.checkValidationLayerSupport", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		u32 layerCount;
		vkEnumerateInstanceLayerProperties(&layerCount, null);
		auto availableLayers = makeArray[VkLayerProperties](layerCount);
		vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.ptr);
		//println("\n", layerCount, " layers supported");

		bool hasAllLayers = checkLayers(validationLayers, availableLayers);

		freeArray[VkLayerProperties](availableLayers);

		tracy_emit_zone_end(ctx);
		return hasAllLayers;
	}

	Array[u8*] getRequiredExtensions() {
		Array[u8*] extensions;

		u32 glfwExtensionCount = 0;
		u8** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

		extensions.putArray(glfwExtensions[0..glfwExtensionCount]);

		if (enableValidationLayers) {
			extensions.put(VK_EXT_DEBUG_UTILS_EXTENSION_NAME.ptr);
		}

		return extensions;
	}

	Status pickPhysicalDevice() {
		@static auto zone = TracyLoc(null, "Client.pickPhysicalDevice", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		u32 deviceCount = 0;
		vkEnumeratePhysicalDevices(vkcontext.instance, &deviceCount, null);

		if (deviceCount == 0) {
			println("failed to find GPUs with Vulkan support!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		auto devices = makeArray[VkPhysicalDevice](deviceCount);
		vkEnumeratePhysicalDevices(vkcontext.instance, &deviceCount, devices.ptr);

		//println("Found ", deviceCount, " devices:");

		i64 bestDeviceScore = 0;
		for (u32 i; i < deviceCount; ++i) {
			SwapchainSupportDetails deviceSwapchainDetails;
			i64 deviceScore = rateDeviceSuitability(devices[i], &deviceSwapchainDetails);
			if (deviceScore > bestDeviceScore) {
				bestDeviceScore = deviceScore;
				vkcontext.physicalDevice = devices[i];
				vkcontext.swapchainSupport.free();
				vkcontext.swapchainSupport = deviceSwapchainDetails;
			}
		}

		freeArray[VkPhysicalDevice](devices);

		if (vkcontext.physicalDevice == null) {
			println("failed to find a suitable GPU!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		//println("Selected device ", physicalDevice, " with score ", bestDeviceScore);

		// Fetch and cache memProperties
		vkGetPhysicalDeviceMemoryProperties(vkcontext.physicalDevice, &vkcontext.memProperties);

		//printMemoryProps();

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	void printMemoryProps() {
		println("Memory types:");
		for (u32 i; i < vkcontext.memProperties.memoryTypeCount; ++i) {
			VkMemoryType memType = vkcontext.memProperties.memoryTypes[i];
			print("- mem ", i, " heap ", memType.heapIndex);
			printMemoryPropFlags(memType.propertyFlags);
			println;
		}
		println("Heaps:");
		for (u32 i; i < vkcontext.memProperties.memoryHeapCount; ++i) {
			VkMemoryHeap memHeap = vkcontext.memProperties.memoryHeaps[i];
			print("- heap ", i, " size ", memHeap.size);
			if (memHeap.flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)   print(" DEVICE_LOCAL_BIT");
			if (memHeap.flags & VK_MEMORY_HEAP_MULTI_INSTANCE_BIT) print(" MULTI_INSTANCE_BIT");
			println;
		}
	}

	@static void printMemoryPropFlags(VkMemoryPropertyFlags f) {
		if (f & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)        print(" DEVICE_LOCAL_BIT");
		if (f & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)        print(" HOST_VISIBLE_BIT");
		if (f & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)       print(" HOST_COHERENT_BIT");
		if (f & VK_MEMORY_PROPERTY_HOST_CACHED_BIT)         print(" HOST_CACHED_BIT");
		if (f & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT)    print(" LAZILY_ALLOCATED_BIT");
		if (f & VK_MEMORY_PROPERTY_PROTECTED_BIT)           print(" PROTECTED_BIT");
		if (f & VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD) print(" DEVICE_COHERENT_BIT_AMD");
		if (f & VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD) print(" DEVICE_UNCACHED_BIT_AMD");
	}

	// negative score means that device is unsuitable
	i64 rateDeviceSuitability(VkPhysicalDevice device, SwapchainSupportDetails* deviceSwapChainSupport) {
		@static auto zone = TracyLoc(null, "Client.rateDeviceSuitability", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		VkPhysicalDeviceProperties deviceProperties;
		vkGetPhysicalDeviceProperties(device, &deviceProperties);

		//println("  ", device, " ", deviceProperties.deviceName.ptr.fromStringz);

		i64 score = 0;

		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
			score += 1000;
			//println("    discrete GPU");
		}

		QueueFamilyIndices indices = findQueueFamilies(device);

		if (!indices.isComplete) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		bool extensionsSupported = checkDeviceExtensionSupport(device);
		if (!extensionsSupported) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		querySwapChainSupport(device, deviceSwapChainSupport);
		bool swapchainAdequate = deviceSwapChainSupport.formats.length > 0 && deviceSwapChainSupport.presentModes.length > 0;

		if (!swapchainAdequate) {
			tracy_emit_zone_end(ctx);
			return -1; // unsuitable
		}

		tracy_emit_zone_end(ctx);
		return score;
	}

	QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
		QueueFamilyIndices indices;

		u32 queueFamilyCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, null);

		auto queueFamilies = makeArray[VkQueueFamilyProperties](queueFamilyCount);
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.ptr);

		for (u32 i; i < queueFamilyCount; ++i) {
			VkQueueFamilyProperties queueFamily = queueFamilies[i];
			if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
				indices.presentFamilies |= QueueFamilyFlags.graphics;
				indices.indices[QueueFamily.graphics] = i;
			}

			VkBool32 presentSupport = false;
			vkGetPhysicalDeviceSurfaceSupportKHR(device, i, vkcontext.swapchain.surface, &presentSupport);
			if (presentSupport) {
				indices.presentFamilies |= QueueFamilyFlags.present;
				indices.indices[QueueFamily.present] = i;
			}
			if (indices.isComplete) break;
		}

		freeArray[VkQueueFamilyProperties](queueFamilies);

		return indices;
	}

	bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
		u32 extensionCount;
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, null);

		auto availableExtensions = makeArray[VkExtensionProperties](extensionCount);
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, availableExtensions.ptr);

		//println("    ", extensionCount, " device extensions");
		//for (u32 i; i < extensionCount; ++i) {
		//	u8[] name = availableExtensions[i].extensionName.ptr.fromStringz;
		//	println("      ", name, " ", availableExtensions[i].specVersion);
		//}

		bool hasAllExtensions = checkExtensions(deviceExtensions, availableExtensions);

		freeArray[VkExtensionProperties](availableExtensions);

		return hasAllExtensions;
	}

	Status createLogicalDevice() {
		@static auto zone = TracyLoc(null, "Client.createLogicalDevice", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		QueueFamilyIndices indices = findQueueFamilies(vkcontext.physicalDevice);
		//println("Queues");
		//println("  Graphics: ", indices.indices[QueueFamily.graphics]);
		//println("   Present: ", indices.indices[QueueFamily.present]);


		// Specify queues to be created in logical device
		Array[VkDeviceQueueCreateInfo] queueCreateInfos;

		f32 queuePriority = 1.0;
		for (u32 i = 0; i < QueueFamilyIndices.NUM_FAMILIES; ++i) {

			bool alreadyExists = false;
			for (u32 j = 0; j < i; ++j) {
				if (indices.indices[i] == indices.indices[j]) {
					alreadyExists = true;
					break;
				}
			}
			if (alreadyExists) continue;

			VkDeviceQueueCreateInfo queueCreateInfo;
			queueCreateInfo.queueFamilyIndex = indices.indices[i];
			queueCreateInfo.queueCount = 1;
			queueCreateInfo.pQueuePriorities = &queuePriority;
			queueCreateInfos.put(queueCreateInfo);
		}


		// Create logical device
		VkDeviceCreateInfo createInfo;

		createInfo.pQueueCreateInfos = queueCreateInfos.ptr;
		createInfo.queueCreateInfoCount = cast(u32)queueCreateInfos.length;

		createInfo.enabledExtensionCount = cast(u32)deviceExtensions.length;
		createInfo.ppEnabledExtensionNames = deviceExtensions.ptr;

		if (enableValidationLayers) {
			createInfo.enabledLayerCount = cast(u32)validationLayers.length;
			createInfo.ppEnabledLayerNames = validationLayers.ptr;
		} else {
			createInfo.enabledLayerCount = 0;
		}

		VkPhysicalDeviceFeatures deviceFeatures;
		createInfo.pEnabledFeatures = &deviceFeatures;

		@static auto zone1 = TracyLoc(null, "vkCreateDevice", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		VkResult vkCreateDeviceResult = vkCreateDevice(vkcontext.physicalDevice, &createInfo, null, &vkcontext.device);
		tracy_emit_zone_end(ctx1);
		queueCreateInfos.free();
		if (vkCreateDeviceResult != VK_SUCCESS) {
			println("failed to create logical device: ");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}
		//println("Logical device ", device);


		// Load functions of this specific device. Only support single device for now
		// For multiple devices either use `loadDeviceLevelFunctions` or `DispatchDevice`
		@static auto zone2 = TracyLoc(null, "loadDeviceLevelFunctionsDirect", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		loadDeviceLevelFunctionsDirect(vkcontext.device);
		tracy_emit_zone_end(ctx2);


		// Retreive queue handles of queues we requested
		vkGetDeviceQueue(vkcontext.device, indices.indices[QueueFamily.graphics], 0, &vkcontext.graphicsQueue);
		vkGetDeviceQueue(vkcontext.device, indices.indices[QueueFamily.present],  0, &vkcontext.presentQueue);

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createSwapChain(VkSwapchainKHR oldSwapchain) {
		@static auto zone = TracyLoc(null, "Client.createSwapChain", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(vkcontext.swapchainSupport.formats);
		VkPresentModeKHR presentMode = chooseSwapPresentMode(vkcontext.swapchainSupport.presentModes);
		VkExtent2D extent = chooseSwapExtent(vkcontext.swapchainSupport.capabilities);

		u32 imageCount = vkcontext.swapchainSupport.capabilities.minImageCount + 1;
		if (vkcontext.swapchainSupport.capabilities.maxImageCount > 0 && imageCount > vkcontext.swapchainSupport.capabilities.maxImageCount) {
			imageCount = vkcontext.swapchainSupport.capabilities.maxImageCount;
		}

		VkSwapchainCreateInfoKHR createInfo;
		createInfo.surface = vkcontext.swapchain.surface;

		createInfo.minImageCount = imageCount;
		createInfo.imageFormat = surfaceFormat.format;
		createInfo.imageColorSpace = surfaceFormat.colorSpace;
		createInfo.imageExtent = extent;
		createInfo.imageArrayLayers = 1;
		createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

		QueueFamilyIndices indices = findQueueFamilies(vkcontext.physicalDevice);

		if (indices.indices[QueueFamily.graphics] != indices.indices[QueueFamily.present]) {
			createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
			createInfo.queueFamilyIndexCount = cast(u32)indices.indices.length;
			createInfo.pQueueFamilyIndices = indices.indices.ptr;
		} else {
			createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
			// createInfo.queueFamilyIndexCount = 0; // noop
			// createInfo.pQueueFamilyIndices = null; // noop
		}

		createInfo.preTransform = vkcontext.swapchainSupport.capabilities.currentTransform;
		createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
		createInfo.presentMode = presentMode;
		createInfo.clipped = VK_TRUE;

		createInfo.oldSwapchain = oldSwapchain;

		@static auto zone2 = TracyLoc(null, "vkCreateSwapchainKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx_vkCreateSwapchainKHR = tracy_emit_zone_begin(&zone2, TRACY_ON);
		if (vkCreateSwapchainKHR(vkcontext.device, &createInfo, null, &vkcontext.swapchain.swapchain) != VK_SUCCESS) {
			println("failed to create swap chain!");
			tracy_emit_zone_end(ctx_vkCreateSwapchainKHR);
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx_vkCreateSwapchainKHR);

		vkGetSwapchainImagesKHR(vkcontext.device, vkcontext.swapchain.swapchain, &vkcontext.swapchain.numImages, null);

		VkImage[vkcontext.swapchain.MAX_IMAGES] swapchainImages;
		vkGetSwapchainImagesKHR(vkcontext.device, vkcontext.swapchain.swapchain, &vkcontext.swapchain.numImages, swapchainImages.ptr);
		for (u32 i = 0; i < vkcontext.swapchain.numImages; ++i) vkcontext.swapchain.images[i].image = swapchainImages[i];

		vkcontext.swapchain.swapchainImageFormat = surfaceFormat.format;
		vkcontext.swapchain.swapchainExtent = extent;

		vkcontext.swapchainSupport.free();

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createImageViews() {
		@static auto zone = TracyLoc(null, "Client.createImageViews", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		for (u32 i = 0; i < vkcontext.swapchain.numImages; ++i) {
			VkImageViewCreateInfo createInfo;
			createInfo.image = vkcontext.swapchain.images[i].image;
			createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
			createInfo.format = vkcontext.swapchain.swapchainImageFormat;
			createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(vkcontext.device, &createInfo, null, &vkcontext.swapchain.images[i].imageView) != VK_SUCCESS) {
				println("failed to create image views!");
				tracy_emit_zone_end(ctx);
				return Status.ERR;
			}
		}
		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createRenderPass() {
		@static auto zone = TracyLoc(null, "Client.createRenderPass", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkAttachmentDescription colorAttachment;
		colorAttachment.format = vkcontext.swapchain.swapchainImageFormat;
		colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
		colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
		colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
		colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

		VkAttachmentReference colorAttachmentRef;
		colorAttachmentRef.attachment = 0;
		colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		VkSubpassDescription subpass;
		subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		subpass.colorAttachmentCount = 1;
		subpass.pColorAttachments = &colorAttachmentRef;

		VkSubpassDependency dependency;
		dependency.srcSubpass = cast(u32)VK_SUBPASS_EXTERNAL;
		dependency.dstSubpass = 0;
		dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency.srcAccessMask = 0;
		dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

		VkRenderPassCreateInfo renderPassInfo;
		renderPassInfo.attachmentCount = 1;
		renderPassInfo.pAttachments = &colorAttachment;
		renderPassInfo.subpassCount = 1;
		renderPassInfo.pSubpasses = &subpass;
		renderPassInfo.dependencyCount = 1;
		renderPassInfo.pDependencies = &dependency;

		if (vkCreateRenderPass(vkcontext.device, &renderPassInfo, null, &vkcontext.swapchain.renderPass) != VK_SUCCESS) {
			println("failed to create render pass!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createDescriptorSetLayout() {
		@static auto zone = TracyLoc(null, "Client.createDescriptorSetLayout", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkDescriptorSetLayoutBinding uboLayoutBinding;
		uboLayoutBinding.binding = 0;
		uboLayoutBinding.descriptorCount = 1;
		uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		uboLayoutBinding.pImmutableSamplers = null;
		uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;

		VkDescriptorSetLayoutCreateInfo layoutInfo;
		layoutInfo.bindingCount = 1;
		layoutInfo.pBindings = &uboLayoutBinding;

		if (vkCreateDescriptorSetLayout(vkcontext.device, &layoutInfo, null, &pipeline.descriptorSetLayout) != VK_SUCCESS) {
			println("failed to create descriptor set layout!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status loadTexture(u8[] path, ImageData* result) {
		u8[] fileData;
		Status err = readFile(path, &fileData);
		//println("file ", fileData.length);

		qoi_desc desc;
		void* pixels = qoi_decode(data: fileData.ptr, size: cast(i32)fileData.length, desc: &desc, channels: 4, malloc: &mi_malloc);

		freeArray[u8](fileData);

		result.ptr = cast(u8*)pixels;
		result.width = desc.width;
		result.height = desc.height;

		if (pixels == null) return Status.ERR;
		//println("img ", path, " w ", result.width, " h ", result.height, " ", cast(u32)desc.colorspace);

		return err;
	}

	Status loadShaders() {
		@static auto zone = TracyLoc(null, "Client.loadShaders", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static auto zone1 = TracyLoc("vertShaderSource", "utils.readFile", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		u8[] vertShaderSource;
		Status err1 = readFile("../plugins/hello_triangle/res/shader.vert", &vertShaderSource);
		tracy_emit_zone_end(ctx1);
		@static auto zone2 = TracyLoc("fragShaderSource", "utils.readFile", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		u8[] fragShaderSource;
		Status err2 = readFile("../plugins/hello_triangle/res/shader.frag", &fragShaderSource);
		tracy_emit_zone_end(ctx2);

		shaderc_compiler_t compiler = shaderc_compiler_initialize();
		u8[] vertShaderCode;
		u8[] fragShaderCode;
		Status err3 = compileShader(&vertShaderCode, compiler, vertShaderSource, "shader.vert", "main", shaderc_shader_kind.shaderc_glsl_vertex_shader);
		Status err4 = compileShader(&fragShaderCode, compiler, fragShaderSource, "shader.frag", "main", shaderc_shader_kind.shaderc_glsl_fragment_shader);

		@static auto zone3 = TracyLoc(null, "shaderc_compiler_release", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
		shaderc_compiler_release(compiler);
		tracy_emit_zone_end(ctx3);

		vertShaderModule = createShaderModule(vertShaderCode);
		fragShaderModule = createShaderModule(fragShaderCode);

		freeArray[u8](vertShaderSource);
		freeArray[u8](fragShaderSource);
		freeArray[u8](vertShaderCode);
		freeArray[u8](fragShaderCode);

		tracy_emit_zone_end(ctx);
		return cast(Status)(err1 || err2 || err3 || err4);
	}

	Status createGraphicsPipeline() {
		@static auto zone = TracyLoc(null, "Client.createGraphicsPipeline", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkPipelineShaderStageCreateInfo vertShaderStageInfo;
		vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
		vertShaderStageInfo.Module = vertShaderModule;
		vertShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo fragShaderStageInfo;
		fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
		fragShaderStageInfo.Module = fragShaderModule;
		fragShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo[2] shaderStages;
		shaderStages[0] = vertShaderStageInfo;
		shaderStages[1] = fragShaderStageInfo;

		VkPipelineVertexInputStateCreateInfo vertexInputInfo;
		vertexInputInfo.vertexBindingDescriptionCount = 0;
		vertexInputInfo.vertexAttributeDescriptionCount = 0;

		VkVertexInputBindingDescription bindingDescription = Vertex.getBindingDescription();
		VkVertexInputAttributeDescription[2] attributeDescriptions = Vertex.getAttributeDescriptions();

		vertexInputInfo.vertexBindingDescriptionCount = 1;
		vertexInputInfo.vertexAttributeDescriptionCount = cast(u32)attributeDescriptions.length;
		vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
		vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.ptr;

		VkPipelineInputAssemblyStateCreateInfo inputAssembly;
		inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		inputAssembly.primitiveRestartEnable = VK_FALSE;

		VkViewport viewport;
		viewport.x = 0.0;
		viewport.y = 0.0;
		viewport.width = cast(f32)vkcontext.swapchain.swapchainExtent.width;
		viewport.height = cast(f32)vkcontext.swapchain.swapchainExtent.height;
		viewport.minDepth = 0.0;
		viewport.maxDepth = 1.0;

		VkRect2D scissor;
		scissor.offset = VkOffset2D(0, 0);
		scissor.extent = vkcontext.swapchain.swapchainExtent;

		VkPipelineViewportStateCreateInfo viewportState;
		viewportState.viewportCount = 1;
		viewportState.pViewports = &viewport;
		viewportState.scissorCount = 1;
		viewportState.pScissors = &scissor;

		VkPipelineRasterizationStateCreateInfo rasterizer;
		rasterizer.depthClampEnable = VK_FALSE;
		rasterizer.rasterizerDiscardEnable = VK_FALSE;
		rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
		rasterizer.lineWidth = 1.0;
		rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
		rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
		rasterizer.depthBiasEnable = VK_FALSE;

		VkPipelineMultisampleStateCreateInfo multisampling;
		multisampling.sampleShadingEnable = VK_FALSE;
		multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

		VkPipelineColorBlendAttachmentState colorBlendAttachment;
		colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
		colorBlendAttachment.blendEnable = VK_FALSE;

		VkPipelineColorBlendStateCreateInfo colorBlending;
		colorBlending.logicOpEnable = VK_FALSE;
		colorBlending.logicOp = VK_LOGIC_OP_COPY;
		colorBlending.attachmentCount = 1;
		colorBlending.pAttachments = &colorBlendAttachment;
		colorBlending.blendConstants[0] = 0.0;
		colorBlending.blendConstants[1] = 0.0;
		colorBlending.blendConstants[2] = 0.0;
		colorBlending.blendConstants[3] = 0.0;

		VkPipelineLayoutCreateInfo pipelineLayoutInfo;
		pipelineLayoutInfo.setLayoutCount = 1;
		pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
		pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional
		pipelineLayoutInfo.pPushConstantRanges = null; // Optional

		@static auto zone4 = TracyLoc(null, "vkCreatePipelineLayout", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		if (vkCreatePipelineLayout(vkcontext.device, &pipelineLayoutInfo, null, &pipeline.pipelineLayout) != VK_SUCCESS) {
			println("failed to create pipeline layout!");
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx4);

		VkGraphicsPipelineCreateInfo pipelineInfo;
		pipelineInfo.stageCount = 2;
		pipelineInfo.pStages = shaderStages.ptr;
		pipelineInfo.pVertexInputState = &vertexInputInfo;
		pipelineInfo.pInputAssemblyState = &inputAssembly;
		pipelineInfo.pViewportState = &viewportState;
		pipelineInfo.pRasterizationState = &rasterizer;
		pipelineInfo.pMultisampleState = &multisampling;
		pipelineInfo.pDepthStencilState = null; // Optional
		pipelineInfo.pColorBlendState = &colorBlending;
		pipelineInfo.pDynamicState = null; // Optional
		pipelineInfo.layout = pipeline.pipelineLayout;
		pipelineInfo.renderPass = vkcontext.swapchain.renderPass;
		pipelineInfo.subpass = 0;

		@static auto zone5 = TracyLoc(null, "vkCreatePipelineLayout", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
		if (vkCreateGraphicsPipelines(vkcontext.device, null, 1, &pipelineInfo, null, &pipeline.graphicsPipeline) != VK_SUCCESS) {
			println("failed to create graphics pipeline!");
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx5);

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createFramebuffers() {
		@static auto zone = TracyLoc(null, "Client.createFramebuffers", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		for (u64 i = 0; i < vkcontext.swapchain.numImages; i++) {
			VkImageView[1] attachments;
			attachments[0] = vkcontext.swapchain.images[i].imageView;

			VkFramebufferCreateInfo framebufferInfo;
			framebufferInfo.renderPass = vkcontext.swapchain.renderPass;
			framebufferInfo.attachmentCount = cast(u32)attachments.length;
			framebufferInfo.pAttachments = attachments.ptr;
			framebufferInfo.width = vkcontext.swapchain.swapchainExtent.width;
			framebufferInfo.height = vkcontext.swapchain.swapchainExtent.height;
			framebufferInfo.layers = 1;

			if (vkCreateFramebuffer(vkcontext.device, &framebufferInfo, null, &vkcontext.swapchain.images[i].framebuffer) != VK_SUCCESS) {
				println("failed to create framebuffer!");
				return Status.ERR;
			}
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createCommandPool() {
		@static auto zone = TracyLoc(null, "Client.createCommandPool", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		QueueFamilyIndices queueFamilyIndices = findQueueFamilies(vkcontext.physicalDevice);

		VkCommandPoolCreateInfo poolInfo;
		poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
		poolInfo.queueFamilyIndex = queueFamilyIndices.indices[QueueFamily.graphics];

		if (vkCreateCommandPool(vkcontext.device, &poolInfo, null, &vkcontext.commandPool) != VK_SUCCESS) {
			println("failed to create command pool!");
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createTextureImage() {
		@static auto zone = TracyLoc(null, "Client.createTextureImage", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		if (loadTexture("../plugins/hello_triangle/res/font_14.qoi", &fontImage) != OK) return Status.ERR;
		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createUniformBuffers() {
		@static auto zone = TracyLoc(null, "Client.createUniformBuffers", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		VkDeviceSize bufferSize = UniformBufferObject.sizeof;
		for (u64 i = 0; i < vkcontext.NUM_FRAMES; ++i) {
			auto frame = &vkcontext.frames[i];
			createOrResizeBarBuffer(&frame.uniformBuffer, bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT);
		}
		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createDescriptorPool() {
		VkDescriptorPoolSize poolSize;
		poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		poolSize.descriptorCount = vkcontext.NUM_FRAMES;

		VkDescriptorPoolCreateInfo poolInfo;
		poolInfo.poolSizeCount = 1;
		poolInfo.pPoolSizes = &poolSize;
		poolInfo.maxSets = vkcontext.NUM_FRAMES;

		if (vkCreateDescriptorPool(vkcontext.device, &poolInfo, null, &vkcontext.descriptorPool) != VK_SUCCESS) {
			println("failed to create descriptor pool!");
			return Status.ERR;
		}
		return Status.OK;
	}

	Status createDescriptorSets() {
		VkDescriptorSetLayout[vkcontext.NUM_FRAMES] layouts;
		for (u64 i = 0; i < vkcontext.NUM_FRAMES; ++i) layouts[i] = pipeline.descriptorSetLayout;

		VkDescriptorSetAllocateInfo allocInfo;
		allocInfo.descriptorPool = vkcontext.descriptorPool;
		allocInfo.descriptorSetCount = vkcontext.NUM_FRAMES;
		allocInfo.pSetLayouts = layouts.ptr;

		VkDescriptorSet[vkcontext.NUM_FRAMES] descriptorSets;
		if (vkAllocateDescriptorSets(vkcontext.device, &allocInfo, descriptorSets.ptr) != VK_SUCCESS) {
			println("failed to allocate descriptor sets!");
			return Status.ERR;
		}

		for (u64 i = 0; i < vkcontext.NUM_FRAMES; ++i) {
			auto frame = &vkcontext.frames[i];
			frame.descriptorSet = descriptorSets[i];

			VkDescriptorBufferInfo bufferInfo;
			bufferInfo.buffer = frame.uniformBuffer.buffer;
			bufferInfo.offset = 0;
			bufferInfo.range = UniformBufferObject.sizeof;

			VkWriteDescriptorSet descriptorWrite;
			descriptorWrite.dstSet = descriptorSets[i];
			descriptorWrite.dstBinding = 0;
			descriptorWrite.dstArrayElement = 0;
			descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
			descriptorWrite.descriptorCount = 1;
			descriptorWrite.pBufferInfo = &bufferInfo;

			vkUpdateDescriptorSets(vkcontext.device, 1, &descriptorWrite, 0, null);
		}
		return Status.OK;
	}

	Status createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer* buffer, VkDeviceMemory* bufferMemory) {
		@static auto zone = TracyLoc(null, "Client.createBuffer", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkBufferCreateInfo bufferInfo;
		bufferInfo.size = size;
		bufferInfo.usage = usage;
		bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

		if (vkCreateBuffer(vkcontext.device, &bufferInfo, null, buffer) != VK_SUCCESS) {
			println("failed to create buffer!");
			return Status.ERR;
		}

		VkMemoryRequirements memRequirements;
		vkGetBufferMemoryRequirements(vkcontext.device, *buffer, &memRequirements);

		VkMemoryAllocateInfo allocInfo;
		allocInfo.allocationSize = memRequirements.size;
		if (findMemoryType(memRequirements.memoryTypeBits, properties, &allocInfo.memoryTypeIndex)) return Status.ERR;

		if (vkAllocateMemory(vkcontext.device, &allocInfo, null, bufferMemory) != VK_SUCCESS) {
			println("failed to allocate buffer memory!");
			return Status.ERR;
		}

		vkBindBufferMemory(vkcontext.device, *buffer, *bufferMemory, 0);

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status findMemoryType(u32 typeFilter, VkMemoryPropertyFlags properties, u32* memType) {
		for (uint32_t i = 0; i < vkcontext.memProperties.memoryTypeCount; i++) {
			if ((typeFilter & (1 << i)) && (vkcontext.memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
				*memType = i;
				return Status.OK;
			}
		}

		println("failed to find suitable memory type!");
		return Status.ERR;
	}

	Status createCommandBuffers() {
		@static auto zone = TracyLoc(null, "Client.createCommandBuffers", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkCommandBuffer[vkcontext.NUM_FRAMES] commandBuffers;

		VkCommandBufferAllocateInfo allocInfo;
		allocInfo.commandPool = vkcontext.commandPool;
		allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocInfo.commandBufferCount = vkcontext.NUM_FRAMES;
		if (vkAllocateCommandBuffers(vkcontext.device, &allocInfo, commandBuffers.ptr) != VK_SUCCESS) {
			println("failed to allocate command buffers!");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}
		for (u32 i; i < vkcontext.NUM_FRAMES; ++i) vkcontext.frames[i].commandBuffer = commandBuffers[i];

		VkCommandBufferAllocateInfo allocInfoUpload;
		allocInfoUpload.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocInfoUpload.commandPool = vkcontext.commandPool;
		allocInfoUpload.commandBufferCount = 1;
		if (vkAllocateCommandBuffers(vkcontext.device, &allocInfoUpload, &vkcontext.uploadCommandBuffer) != VK_SUCCESS) {
			println("failed to allocate upload command buffer");
			tracy_emit_zone_end(ctx);
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	void createOrResizeBarBuffer(BarBuffer* buffer, VkDeviceSize newSize, VkBufferUsageFlags bufUsage) {
		VkDeviceSize allocSize = nextPOT[VkDeviceSize](newSize);
		if (buffer.size >= allocSize) return;

		freeBarBuffer(buffer);

		VkBufferCreateInfo bufCreateInfo;
		bufCreateInfo.size = allocSize;
		bufCreateInfo.usage = bufUsage;
		bufCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

		VmaAllocationCreateInfo allocCreateInfo;
		allocCreateInfo.usage = VmaMemoryUsage.VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE;
		allocCreateInfo.flags = VmaAllocationCreateFlagBits.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
			VmaAllocationCreateFlagBits.VMA_ALLOCATION_CREATE_MAPPED_BIT;

		VmaAllocationInfo allocInfo;
		vmaCreateBuffer(vkcontext.vkallocator, &bufCreateInfo, &allocCreateInfo, &buffer.buffer, &buffer.allocation, &allocInfo);
		buffer.size = allocInfo.size;

		//VkMemoryPropertyFlags memPropFlags = vkcontext.memProperties.memoryTypes[allocInfo.memoryType].propertyFlags;
		//print("Alloced buf: offset ", allocInfo.offset, " size ", allocInfo.size);
		//printMemoryPropFlags(memPropFlags);
		//println;
	}

	void freeBarBuffer(BarBuffer* buffer) {
		vmaDestroyBuffer(vkcontext.vkallocator, buffer.buffer, buffer.allocation);
		*buffer = BarBuffer();
	}

	Status recordCommandBuffer(VkCommandBuffer cmdBuf, u32 imageIndex, FrameData* frame) {
		@static auto zone = TracyLoc(null, "Client.recordCommandBuffer", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		createOrResizeBarBuffer(&frame.vertexBuffer, vertices.byteLength, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);
		createOrResizeBarBuffer(&frame.indexBuffer,  indicies.byteLength, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);

		fillBarBuffer(&frame.vertexBuffer, vertices.ptr, vertices.byteLength);
		fillBarBuffer(&frame.indexBuffer, indicies.ptr, indicies.byteLength);

		VkCommandBufferBeginInfo beginInfo;

		if (vkBeginCommandBuffer(cmdBuf, &beginInfo) != VK_SUCCESS) {
			println("failed to begin recording command buffer!");
			return Status.ERR;
		}

		VkRenderPassBeginInfo renderPassInfo;
		renderPassInfo.renderPass = vkcontext.swapchain.renderPass;
		renderPassInfo.framebuffer = vkcontext.swapchain.images[imageIndex].framebuffer;
		renderPassInfo.renderArea.offset = VkOffset2D(0, 0);
		renderPassInfo.renderArea.extent = vkcontext.swapchain.swapchainExtent;

		VkClearValue clearColor;
		clearColor.color.float32[0] = 0.0;
		clearColor.color.float32[1] = 0.0;
		clearColor.color.float32[2] = 0.0;
		clearColor.color.float32[3] = 1.0;
		renderPassInfo.clearValueCount = 1;
		renderPassInfo.pClearValues = &clearColor;

		vkCmdBeginRenderPass(cmdBuf, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);

			vkCmdBindPipeline(cmdBuf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.graphicsPipeline);

			VkDeviceSize offset = 0;
			vkCmdBindVertexBuffers(cmdBuf, 0, 1, &frame.vertexBuffer.buffer, &offset);

			vkCmdBindIndexBuffer(cmdBuf, frame.indexBuffer.buffer, 0, VK_INDEX_TYPE_UINT16);

			vkCmdBindDescriptorSets(cmdBuf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelineLayout, 0, 1, &frame.descriptorSet, 0, null);

			vkCmdDrawIndexed(cmdBuf, indicies.length, 1, 0, 0, 0);

		vkCmdEndRenderPass(cmdBuf);

		if (vkEndCommandBuffer(cmdBuf) != VK_SUCCESS) {
			println("failed to record command buffer!");
			return Status.ERR;
		}

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	Status createSyncObjects() {
		@static auto zone = TracyLoc(null, "Client.createSyncObjects", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkSemaphoreCreateInfo semaphoreInfo;

		VkFenceCreateInfo fenceInfo;
		fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

		for (u64 i = 0; i < vkcontext.NUM_FRAMES; i++) {
			auto frame = &vkcontext.frames[i];
			if (vkCreateSemaphore(vkcontext.device, &semaphoreInfo, null, &frame.imageAvailableSemaphore) != VK_SUCCESS ||
				vkCreateSemaphore(vkcontext.device, &semaphoreInfo, null, &frame.renderFinishedSemaphore) != VK_SUCCESS ||
				vkCreateFence(vkcontext.device, &fenceInfo, null, &frame.inFlightFence) != VK_SUCCESS) {
				println("failed to create synchronization objects for a frame!");
				return Status.ERR;
			}
		}

		VkFenceCreateInfo fenceInfo2;
		if (vkCreateFence(vkcontext.device, &fenceInfo2, null, &vkcontext.uploadFence) != VK_SUCCESS) return Status.ERR;

		tracy_emit_zone_end(ctx);
		return Status.OK;
	}

	void fillBarBuffer(BarBuffer* buffer, void* ptr, u64 length) {
		VmaAllocationInfo allocInfo;
		vmaGetAllocationInfo(vkcontext.vkallocator, buffer.allocation, &allocInfo);
		memcpy(allocInfo.pMappedData, ptr, length);
		VkMemoryPropertyFlags memPropFlags = vkcontext.memProperties.memoryTypes[allocInfo.memoryType].propertyFlags;
		if ((memPropFlags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) == 0) {
			vmaFlushAllocation(vkcontext.vkallocator, buffer.allocation, 0, cast(u64)VK_WHOLE_SIZE);
		}
	}

	Status drawFrame(f32 time) {
		@static auto zone = TracyLoc(null, "Client.drawFrame", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		auto frame = &vkcontext.frames[vkcontext.frameIndex];

		@static auto zone1 = TracyLoc(null, "vkWaitForFences", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		vkWaitForFences(vkcontext.device, 1, &frame.inFlightFence, VK_TRUE, u64.max);
		tracy_emit_zone_end(ctx1);

		@static auto zone4 = TracyLoc(null, "vkResetFences", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		vkResetFences(vkcontext.device, 1, &frame.inFlightFence);
		tracy_emit_zone_end(ctx4);

		u32 imageIndex;
		@static auto zone2 = TracyLoc(null, "vkAcquireNextImageKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		VkResult result = vkAcquireNextImageKHR(vkcontext.device, vkcontext.swapchain.swapchain, u64.max, frame.imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex);
		if (result == VK_ERROR_OUT_OF_DATE_KHR) {
			if (recreateSwapChain() != OK) return Status.ERR;
		} else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
			println("failed to acquire swap chain image!");
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx2);

		vkResetCommandBuffer(frame.commandBuffer, /*VkCommandBufferResetFlagBits*/ 0);
		recordCommandBuffer(frame.commandBuffer, imageIndex, frame);

		// Update uniforms
		UniformBufferObject ubo;
		ubo.model = identityMatrix; //rotationMatrixZ(time * degtorad(90));
		ubo.view = lookAtMatrix(vec3(0, 0, -1), vec3(0, 0, 0), vec3(0, 1, 0));
		//ubo.proj = perspectiveMatrix(degtorad(45), cast(f32)vkcontext.swapchain.swapchainExtent.height / vkcontext.swapchain.swapchainExtent.width, 0.1, 10);
		ubo.proj = perspectiveMatrix(degtorad(90), 1, 0.1, 10);
		fillBarBuffer(&frame.uniformBuffer, &ubo, ubo.sizeof);


		VkSubmitInfo submitInfo;

		VkSemaphore waitSemaphore = frame.imageAvailableSemaphore;
		VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		submitInfo.waitSemaphoreCount = 1;
		submitInfo.pWaitSemaphores = &waitSemaphore;
		submitInfo.pWaitDstStageMask = &waitStage;

		submitInfo.commandBufferCount = 1;
		submitInfo.pCommandBuffers = &frame.commandBuffer;

		VkSemaphore signalSemaphore = frame.renderFinishedSemaphore;
		submitInfo.signalSemaphoreCount = 1;
		submitInfo.pSignalSemaphores = &signalSemaphore;

		@static auto zone5 = TracyLoc(null, "vkQueueSubmit", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
		if (vkQueueSubmit(vkcontext.graphicsQueue, 1, &submitInfo, frame.inFlightFence) != VK_SUCCESS) {
			println("failed to submit draw command buffer!");
			return Status.ERR;
		}
		tracy_emit_zone_end(ctx5);

		VkPresentInfoKHR presentInfo;

		presentInfo.waitSemaphoreCount = 1;
		presentInfo.pWaitSemaphores = &signalSemaphore;

		presentInfo.swapchainCount = 1;
		presentInfo.pSwapchains = &vkcontext.swapchain.swapchain;

		presentInfo.pImageIndices = &imageIndex;

		@static auto zone6 = TracyLoc(null, "vkQueuePresentKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx6 = tracy_emit_zone_begin(&zone6, TRACY_ON);
		result = vkQueuePresentKHR(vkcontext.presentQueue, &presentInfo);
		tracy_emit_zone_end(ctx6);

		if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) {
			//println("recreateSwapChain ", result == VK_ERROR_OUT_OF_DATE_KHR, " ", result == VK_SUBOPTIMAL_KHR, " ", framebufferResized);
			if (recreateSwapChain() != OK) return Status.ERR;
		} else if (result != VK_SUCCESS) {
			println("failed to present swap chain image!");
			return Status.ERR;
		}

		vkcontext.frameIndex = (vkcontext.frameIndex + 1) % vkcontext.NUM_FRAMES;

		tracy_emit_zone_end(ctx);

		return Status.OK;
	}

	Status compileShader(u8[]* outData, shaderc_compiler_t compiler, u8[] source, u8[] filename, u8* entryname, shaderc_shader_kind shader_kind) {
		@static auto zone = TracyLoc(null, "Client.compileShader", "main.vx", cast(u32)__LINE__, 0xAAAA00); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static auto zone1 = TracyLoc(null, "shaderc_compile_into_spv", "main.vx", cast(u32)__LINE__, 0xAAAA00); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		shaderc_compilation_result_t result = shaderc_compile_into_spv(
			compiler, source.ptr, source.length,
			shader_kind, filename.ptr, entryname, null);
		tracy_emit_zone_end(ctx1);

		u64 numWarnings = shaderc_result_get_num_warnings(result);
		u64 numErrors = shaderc_result_get_num_errors(result);

		shaderc_compilation_status status = shaderc_result_get_compilation_status(result);

		//println("Compiled `", filename, "` with ", numWarnings, " warnings, ", numErrors, " errors, status: ", cast(u32)status);

		if (numWarnings != 0 || numErrors != 0) {
			u8* msg = shaderc_result_get_error_message(result);
			print(msg.fromStringz);
			return Status.ERR;
		}

		u64 resLength = shaderc_result_get_length(result);
		u8* ptr = shaderc_result_get_bytes(result);
		*outData = makeVoidArray[u8](resLength);
		memcopy(*outData, ptr[0..resLength]);

		shaderc_result_release(result);

		tracy_emit_zone_end(ctx);

		return Status.OK;
	}

	VkShaderModule createShaderModule(u8[] code) {
		@static auto zone = TracyLoc(null, "Client.createShaderModule", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		VkShaderModuleCreateInfo createInfo;
		createInfo.codeSize = code.length; // size is in bytes
		createInfo.pCode = cast(u32*)code.ptr;

		VkShaderModule shaderModule;
		if (vkCreateShaderModule(vkcontext.device, &createInfo, null, &shaderModule) != VK_SUCCESS) {
			println("failed to create shader module!");
			isRunning = false;
		}

		tracy_emit_zone_end(ctx);

		return shaderModule;
	}

	VkSurfaceFormatKHR chooseSwapSurfaceFormat(Array[VkSurfaceFormatKHR] availableFormats) {
		@static auto zone = TracyLoc(null, "Client.chooseSwapSurfaceFormat", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		for (u32 i = 0; i < availableFormats.length; ++i) {
			VkSurfaceFormatKHR availableFormat = availableFormats.ptr[i];
			if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
				tracy_emit_zone_end(ctx);
				return availableFormat;
			}
		}

		tracy_emit_zone_end(ctx);

		return availableFormats.ptr[0];
	}

	VkPresentModeKHR chooseSwapPresentMode(Array[VkPresentModeKHR] availablePresentModes) {
		@static auto zone = TracyLoc(null, "Client.chooseSwapPresentMode", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);
		for (u32 i = 0; i < availablePresentModes.length; ++i) {
			VkPresentModeKHR availablePresentMode = availablePresentModes.ptr[i];
			if (availablePresentMode == PRESENT_MODE) {
				tracy_emit_zone_end(ctx);
				return availablePresentMode;
			}
		}

		tracy_emit_zone_end(ctx);

		return VK_PRESENT_MODE_FIFO_KHR;
	}

	VkExtent2D chooseSwapExtent(VkSurfaceCapabilitiesKHR capabilities) {
		@static auto zone = TracyLoc(null, "Client.chooseSwapExtent", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		if (capabilities.currentExtent.width != u32.max) {
			tracy_emit_zone_end(ctx);
			return capabilities.currentExtent;
		} else {
			i32 width;
			i32 height;
			glfwGetFramebufferSize(window, &width, &height);

			VkExtent2D actualExtent = VkExtent2D(cast(u32)width, cast(u32)height);

			actualExtent.width = clamp[u32](actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
			actualExtent.height = clamp[u32](actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

			tracy_emit_zone_end(ctx);
			return actualExtent;
		}
	}

	void querySwapChainSupport(VkPhysicalDevice device, SwapchainSupportDetails* result) {
		@static auto zone = TracyLoc(null, "Client.querySwapChainSupport", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx = tracy_emit_zone_begin(&zone, TRACY_ON);

		@static auto zone1 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx1 = tracy_emit_zone_begin(&zone1, TRACY_ON);
		vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, vkcontext.swapchain.surface, &result.capabilities);
		tracy_emit_zone_end(ctx1);

		u32 formatCount;
		@static auto zone2 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceFormatsKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx2 = tracy_emit_zone_begin(&zone2, TRACY_ON);
		vkGetPhysicalDeviceSurfaceFormatsKHR(device, vkcontext.swapchain.surface, &formatCount, null);
		tracy_emit_zone_end(ctx2);

		if (formatCount) {
			VkSurfaceFormatKHR* ptr = result.formats.putVoid(formatCount);
			@static auto zone3 = TracyLoc(null, "vkGetPhysicalDeviceSurfaceFormatsKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx3 = tracy_emit_zone_begin(&zone3, TRACY_ON);
			vkGetPhysicalDeviceSurfaceFormatsKHR(device, vkcontext.swapchain.surface, &formatCount, ptr);
			tracy_emit_zone_end(ctx3);
		}

		u32 presentModeCount;
		@static auto zone4 = TracyLoc(null, "vkGetPhysicalDeviceSurfacePresentModesKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
		vkGetPhysicalDeviceSurfacePresentModesKHR(device, vkcontext.swapchain.surface, &presentModeCount, null);
		tracy_emit_zone_end(ctx4);

		if (presentModeCount != 0) {
			@static auto zone4 = TracyLoc(null, "result.presentModes.putVoid", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx4 = tracy_emit_zone_begin(&zone4, TRACY_ON);
			VkPresentModeKHR* ptr = result.presentModes.putVoid(presentModeCount);
			tracy_emit_zone_end(ctx4);
			@static auto zone5 = TracyLoc(null, "vkGetPhysicalDeviceSurfacePresentModesKHR", "main.vx", cast(u32)__LINE__, 0x000000); auto ctx5 = tracy_emit_zone_begin(&zone5, TRACY_ON);
			vkGetPhysicalDeviceSurfacePresentModesKHR(device, vkcontext.swapchain.surface, &presentModeCount, ptr);
			tracy_emit_zone_end(ctx5);
		}

		tracy_emit_zone_end(ctx);
	}

	void onKey(i32 key, i32 scancode, i32 action, i32 mods) {
		//println("onKey key:", key, " scancode:", scancode, " action:", action, " mods:", mods);

		if (key == GLFW_KEY_R && action == GLFW_PRESS) {
			vertices.clear;
			indicies.clear;
		}
	}

	void onMouseClick(int button, int action, int mods, f32 x, f32 y) {
		if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) {
			putQuadAt(vec3(x*2-1, y*2-1, 0));
		}
	}

	void onFramebufferResize(i32 width, i32 height)
	{
		//println("Resized to ", width, " ", height);
		framebufferResized = true;
	}
}

struct QueueFamilyIndices {
	enum u32 NUM_FAMILIES = 2;

	QueueFamilyFlags presentFamilies; // specifies which families have valid index
	u32[NUM_FAMILIES] indices;


	bool isComplete() #inline {
		enum requiredFamilies = QueueFamilyFlags.graphics | QueueFamilyFlags.present;
		return (presentFamilies & requiredFamilies) == requiredFamilies;
	}
}

enum QueueFamily : u32 {
	graphics = 0,
	present  = 1,
}
enum QueueFamilyFlags : u32 {
	graphics = 0b0000_0001,
	present  = 0b0000_0010,
}

u32 debugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
	void* pUserData) {

	println("validation layer: ", pCallbackData.pMessage.fromStringz);

	return VK_FALSE;
}

bool checkLayers(u8*[] requestedLayers, VkLayerProperties[] availableLayers)
{
	for (i32 i; i < requestedLayers.length; ++i) {
		u8[] requestedLayer = requestedLayers[i].fromStringz;
		//println("req ", requestedLayer);
		bool layerFound = false;
		for (i32 j; j < availableLayers.length; ++j) {
			u8[] name = availableLayers[j].layerName.ptr.fromStringz;
			//println("  ", name, " ", availableLayers[j].specVersion, " ", availableLayers[j].implementationVersion, " ", availableLayers[j].description.ptr.fromStringz);
			if (equal[u8[]](name, requestedLayer)) {
				layerFound = true;
				break;
			}
		}
		if (!layerFound) {
			return false;
		}
	}
	return true;
}

bool checkExtensions(u8*[] requestedExtensions, VkExtensionProperties[] availableExtensions)
{
	for (i32 i; i < requestedExtensions.length; ++i) {
		u8[] requestedExtension = requestedExtensions[i].fromStringz;
		bool extensionFound = false;
		for (i32 j; j < availableExtensions.length; ++j) {
			u8[] name = availableExtensions[j].extensionName.ptr.fromStringz;
			if (equal[u8[]](name, requestedExtension)) {
				extensionFound = true;
				break;
			}
		}
		if (!extensionFound) {
			return false;
		}
	}
	return true;
}

struct Color {
	u8 r;
	u8 g;
	u8 b;
	u8 a = 255;
}

struct Vertex
{
	vec3 pos;
	Color color;

	@static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription;
		bindingDescription.binding = 0;
		bindingDescription.stride = cast(u32)Vertex.sizeof;
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

		return bindingDescription;
	}

	@static VkVertexInputAttributeDescription[2] getAttributeDescriptions() {
		VkVertexInputAttributeDescription[2] attributeDescriptions;

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[0].offset = cast(u32)Vertex.pos.offsetof;

		attributeDescriptions[1].binding = 0;
		attributeDescriptions[1].location = 1;
		attributeDescriptions[1].format = VK_FORMAT_R8G8B8A8_UNORM;
		attributeDescriptions[1].offset = cast(u32)Vertex.color.offsetof;

		return attributeDescriptions;
	}
}

struct UniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
}

struct AllocatedBuffer {
	VkBuffer buffer;
	VmaAllocation allocation;
}
