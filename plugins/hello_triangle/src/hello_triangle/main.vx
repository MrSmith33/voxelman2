module hello_triangle.main;

import core.enet;
import core.glfw3;
import core.host;
import core.kernel32;
import core.mdbx;
import core.shaderc;
import core.tracy;
import core.utils;
import core.vulkan.functions;
import core.vulkan.types;

void run()
{
	Client client;
	client.run();
}

u8[] frame_name = "Frame";
TracyLoc zone_loc1 = TracyLoc("glfwPollEvents", "update()", "main.vx", 83, 0x00AA00);
TracyLoc zone_loc2 = TracyLoc("sleep(1)", "update()", "main.vx", 85, 0x00CC00);

struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR  capabilities;
	Array[VkSurfaceFormatKHR] formats;
	Array[VkPresentModeKHR]   presentModes;

	void free() {
		formats.free();
		presentModes.free();
	}
}

struct Client
{
	GLFWwindow* window;
	MDBX_env* mdbxEnv;

	VkInstance instance;
	VkDebugUtilsMessengerEXT debugMessenger;
	VkSurfaceKHR surface;

	VkPhysicalDevice physicalDevice;
	VkDevice device; // logical device

	VkQueue graphicsQueue;
	VkQueue presentQueue;

	VkSwapchainKHR swapChain;
	VkImage[] swapChainImages;
	VkFormat swapChainImageFormat;
	VkExtent2D swapChainExtent;
	VkImageView[] swapChainImageViews;

	VkPipelineLayout pipelineLayout;

	enum WIDTH = 800;
	enum HEIGHT = 600;

	bool enableValidationLayers = true;
	u8*[1] validationLayers;
	u8*[1] deviceExtensions;

	bool isRunning = true;

	void run()
	{
		println("Start");
		init();
		mainLoop();
		free();
		println("Shutdown");
	}

	void init()
	{
		validationLayers[0] = "VK_LAYER_KHRONOS_validation";
		deviceExtensions[0] = "VK_KHR_swapchain";

		initWindow();
		initVulkan();
		if (!isRunning) return;

		enet_initialize();

		u8[] path = "test.db";
		mdbx_env_create(&mdbxEnv);
		mdbx_env_open(
			mdbxEnv,
			path.ptr,
			MDBX_env_flags_t.MDBX_NOSUBDIR |
			MDBX_env_flags_t.MDBX_EXCLUSIVE,
			//rwx_rwx_rwx
			0b110_110_110);
	}

	void free()
	{
		mdbx_env_close_ex(mdbxEnv);

		enet_deinitialize();

		vkDestroyPipelineLayout(device, pipelineLayout, null);

		for (u64 i = 0; i < swapChainImageViews.length; ++i) {
			vkDestroyImageView(device, swapChainImageViews[i], null);
		}
		swapChainImageViews = freeArray[VkImageView](swapChainImageViews);

		vkDestroySwapchainKHR(device, swapChain, null);
		vkDeviceWaitIdle(device);
		vkDestroyDevice(device, null);

		if (enableValidationLayers) {
			vkDestroyDebugUtilsMessengerEXT(instance, debugMessenger, null);
		}

		vkDestroySurfaceKHR(instance, surface, null);
		vkDestroyInstance(instance, null);
		glfwDestroyWindow(window);
		glfwTerminate();
	}

	void mainLoop()
	{
		while(isRunning && !glfwWindowShouldClose(window)) {
			___tracy_emit_frame_mark();

			update();
		}
	}

	void update()
	{
		TracyZoneCtx tracy_ctx1 = ___tracy_emit_zone_begin(&zone_loc1, 1);
		glfwPollEvents();
		___tracy_emit_zone_end(tracy_ctx1);
		TracyZoneCtx tracy_ctx2 = ___tracy_emit_zone_begin(&zone_loc2, 1);
		Sleep(1);
		___tracy_emit_zone_end(tracy_ctx2);
	}

	void initWindow()
	{
		if (!glfwInit()) {
			println("GLFW init failed");
			isRunning = false;
			return;
		}

		// Do not create OpenGL context
		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

		window = glfwCreateWindow(WIDTH, HEIGHT, "Voxelman", null, null);

		glfwSetWindowUserPointer(window, this);
		glfwSetKeyCallback(window, &glfw_key_callback);
	}

	void initVulkan()
	{
		if (!glfwVulkanSupported) {
			println("Vulkan is not supported");
			isRunning = false;
			return;
		}

		loadGlobalLevelFunctions( cast(PFN_vkGetInstanceProcAddr)glfwGetInstanceProcAddress(null, "vkGetInstanceProcAddr"));

		createInstance();
		if (!isRunning) return;
		setupDebugMessenger();
		if (!isRunning) return;
		createSurface();
		if (!isRunning) return;
		pickPhysicalDevice();
		if (!isRunning) return;
		createLogicalDevice();
		if (!isRunning) return;
		createSwapChain();
		if (!isRunning) return;
		createImageViews();
		if (!isRunning) return;
		createGraphicsPipeline();
	}

	void createInstance()
	{
		VkApplicationInfo appInfo;
		appInfo.pApplicationName = "Hello Triangle";
		appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
		appInfo.pEngineName = "Voxelman";
		appInfo.engineVersion = VK_MAKE_VERSION(2, 0, 0);
		appInfo.apiVersion = VK_API_VERSION_1_0;

		VkInstanceCreateInfo createInfo;
		createInfo.pApplicationInfo = &appInfo;

		Array[u8*] extensions = getRequiredExtensions;

		println("Requesting ", extensions.length, " extensions:");
		for (i32 i; i < extensions.length; ++i) {
			println("  ", extensions.ptr[i].fromStringz);
		}

		createInfo.enabledExtensionCount = extensions.length;
		createInfo.ppEnabledExtensionNames = extensions.ptr;

		VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
		if (enableValidationLayers) {
			if (!checkValidationLayerSupport()) {
				println("Validation layers requested, but not available!");
			} else {
				createInfo.enabledLayerCount = cast(u32)validationLayers.length;
				createInfo.ppEnabledLayerNames = validationLayers.ptr;
				println("Validation ", createInfo.enabledLayerCount, " ", createInfo.ppEnabledLayerNames[0], " ", this);

				populateDebugMessengerCreateInfo(&debugCreateInfo);
				createInfo.pNext = &debugCreateInfo;
			}
		} else {
			createInfo.enabledLayerCount = 0;
		}

		println("vkCreateInstance ", cast(void*)vkCreateInstance, " ", cast(void*)&createInfo, " ", cast(void*)&appInfo);
		i32 vkCreateInstanceResult = cast(i32)vkCreateInstance(&createInfo, null, &instance);
		if (vkCreateInstanceResult != VK_SUCCESS) {
			println("vkCreateInstance failed: ", vkCreateInstanceResult);
			isRunning = false;
			return;
		}
		println("VkInstance ", cast(void*)instance);
		loadInstanceLevelFunctions(instance);

		{
			u32 extensionCount;
			vkEnumerateInstanceExtensionProperties(null, &extensionCount, null);
			println("\n", extensionCount, " instance extensions supported");
			VkExtensionProperties[] extensions = makeArray[VkExtensionProperties](extensionCount);
			vkEnumerateInstanceExtensionProperties(null, &extensionCount, extensions.ptr);
			for (i32 i; i < extensionCount; ++i) {
				println("  ", extensions[i].extensionName.ptr.fromStringz, " ", extensions[i].specVersion);
			}
			freeArray[VkExtensionProperties](extensions);
		}
	}

	void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT* createInfo) {
		createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
		//createInfo.messageSeverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
		createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
		createInfo.pfnUserCallback = &debugCallback; // compiler bug
		createInfo.pUserData = null; // Optional
	}

	void setupDebugMessenger() {
		if (!enableValidationLayers) return;

		VkDebugUtilsMessengerCreateInfoEXT createInfo;
		populateDebugMessengerCreateInfo(&createInfo);

		if (vkCreateDebugUtilsMessengerEXT(instance, &createInfo, null, &debugMessenger) != VK_SUCCESS) {
			println("failed to set up debug messenger!");
			isRunning = false;
		}
	}

	void createSurface() {
		if (glfwCreateWindowSurface(instance, window, null, &surface) != VK_SUCCESS) {
			println("failed to create window surface!");
			isRunning = false;
		}
	}

	bool checkValidationLayerSupport() {
		u32 layerCount;
		vkEnumerateInstanceLayerProperties(&layerCount, null);
		VkLayerProperties[] availableLayers = makeArray[VkLayerProperties](layerCount);
		vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.ptr);
		println("\n", layerCount, " layers supported");

		bool hasAllLayers = checkLayers(validationLayers, availableLayers);

		println("has VK_LAYER_KHRONOS_validation: ", hasAllLayers);
		freeArray[VkLayerProperties](availableLayers);

		return hasAllLayers;
	}

	Array[u8*] getRequiredExtensions() {
		Array[u8*] extensions;

		u32 glfwExtensionCount = 0;
		u8** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

		extensions.putArray(glfwExtensions[0..glfwExtensionCount]);

		if (enableValidationLayers) {
			extensions.put(VK_EXT_DEBUG_UTILS_EXTENSION_NAME.ptr);
		}

		return extensions;
	}

	void pickPhysicalDevice() {
		u32 deviceCount = 0;
		vkEnumeratePhysicalDevices(instance, &deviceCount, null);

		if (deviceCount == 0) {
			println("failed to find GPUs with Vulkan support!");
			isRunning = false;
			return;
		}

		VkPhysicalDevice[] devices = makeArray[VkPhysicalDevice](deviceCount);
		vkEnumeratePhysicalDevices(instance, &deviceCount, devices.ptr);

		println("Found ", deviceCount, " devices:");

		i64 bestDeviceScore = 0;
		for (u32 i; i < deviceCount; ++i) {
			i64 deviceScore = rateDeviceSuitability(devices[i]);
			if (deviceScore > bestDeviceScore) {
				bestDeviceScore = deviceScore;
				physicalDevice = devices[i];
			}
		}

		freeArray[VkPhysicalDevice](devices);

		if (physicalDevice == null) {
			println("failed to find a suitable GPU!");
			isRunning = false;
			return;
		}

		println("Selected device ", physicalDevice, " with score ", bestDeviceScore);
	}

	// negative score means that device is unsuitable
	i64 rateDeviceSuitability(VkPhysicalDevice device) {
		VkPhysicalDeviceProperties deviceProperties;
		vkGetPhysicalDeviceProperties(device, &deviceProperties);

		println("  ", device, " ", deviceProperties.deviceName.ptr.fromStringz);

		VkPhysicalDeviceFeatures deviceFeatures;
		vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

		i64 score = 0;

		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
			score += 1000;
			println("    discrete GPU");
		}

		QueueFamilyIndices indices = findQueueFamilies(device);

		if (!indices.isComplete) return -1; // unsuitable

		bool extensionsSupported = checkDeviceExtensionSupport(device);
		if (!extensionsSupported) return -1;

		bool swapChainAdequate = false;
		if (extensionsSupported) {
			SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
			swapChainAdequate = swapChainSupport.formats.length > 0 && swapChainSupport.presentModes.length > 0;
			swapChainSupport.free();
		}
		if (!swapChainAdequate) return -1;

		return score;
	}

	QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
		QueueFamilyIndices indices;

		u32 queueFamilyCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, null);

		VkQueueFamilyProperties[] queueFamilies = makeArray[VkQueueFamilyProperties](queueFamilyCount);
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.ptr);

		for (u32 i; i < queueFamilyCount; ++i) {
			VkQueueFamilyProperties queueFamily = queueFamilies[i];
			if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
				indices.presentFamilies |= QueueFamilyFlags.graphics;
				indices.indices[QueueFamily.graphics] = i;
			}

			VkBool32 presentSupport = false;
			vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
			if (presentSupport) {
				indices.presentFamilies |= QueueFamilyFlags.present;
				indices.indices[QueueFamily.present] = i;
			}
			if (indices.isComplete) break;
		}

		freeArray[VkQueueFamilyProperties](queueFamilies);

		return indices;
	}

	//bool isDeviceSuitable(VkPhysicalDevice device) {
	//	VkPhysicalDeviceProperties deviceProperties;
	//	vkGetPhysicalDeviceProperties(device, &deviceProperties);

	//	VkPhysicalDeviceFeatures deviceFeatures;
	//	vkGetPhysicalDeviceFeatures(device, &deviceFeatures);
	//	return true;
	//}

	bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
		u32 extensionCount;
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, null);

		VkExtensionProperties[] availableExtensions = makeArray[VkExtensionProperties](extensionCount);
		vkEnumerateDeviceExtensionProperties(device, null, &extensionCount, availableExtensions.ptr);

		//println("    ", extensionCount, " device extensions");
		//for (u32 i; i < extensionCount; ++i) {
		//	u8[] name = availableExtensions[i].extensionName.ptr.fromStringz;
		//	println("      ", name, " ", availableExtensions[i].specVersion);
		//}

		bool hasAllExtensions = checkExtensions(deviceExtensions, availableExtensions);

		freeArray[VkExtensionProperties](availableExtensions);

		return hasAllExtensions;
	}

	void createLogicalDevice() {
		QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
		println("Queues");
		println("  Graphics: ", indices.indices[QueueFamily.graphics]);
		println("   Present: ", indices.indices[QueueFamily.present]);


		// Specify queues to be created in logical device
		Array[VkDeviceQueueCreateInfo] queueCreateInfos;

		f32 queuePriority = 1.0;
		for (u32 i = 0; i < QueueFamilyIndices.NUM_FAMILIES; ++i) {

			bool alreadyExists = false;
			for (u32 j = 0; j < i; ++j) {
				if (indices.indices[i] == indices.indices[j]) {
					alreadyExists = true;
					break;
				}
			}
			if (alreadyExists) continue;

			VkDeviceQueueCreateInfo queueCreateInfo;
			queueCreateInfo.queueFamilyIndex = indices.indices[i];
			queueCreateInfo.queueCount = 1;
			queueCreateInfo.pQueuePriorities = &queuePriority;
			queueCreateInfos.put(queueCreateInfo);
		}


		// Create logical device
		VkDeviceCreateInfo createInfo;

		createInfo.pQueueCreateInfos = queueCreateInfos.ptr;
		createInfo.queueCreateInfoCount = cast(u32)queueCreateInfos.length;

		createInfo.enabledExtensionCount = cast(u32)deviceExtensions.length;
		createInfo.ppEnabledExtensionNames = deviceExtensions.ptr;

		if (enableValidationLayers) {
			createInfo.enabledLayerCount = cast(u32)validationLayers.length;
			createInfo.ppEnabledLayerNames = validationLayers.ptr;
		} else {
			createInfo.enabledLayerCount = 0;
		}

		VkPhysicalDeviceFeatures deviceFeatures;
		createInfo.pEnabledFeatures = &deviceFeatures;

		VkResult vkCreateDeviceResult = vkCreateDevice(physicalDevice, &createInfo, null, &device);
		queueCreateInfos.free();
		if (vkCreateDeviceResult != VK_SUCCESS) {
			println("failed to create logical device: ");
			isRunning = false;
			return;
		}
		println("Logical device ", device);


		// Load functions of this specific device. Only support single device for now
		// For multiple devices either use `loadDeviceLevelFunctions` or `DispatchDevice`
		loadDeviceLevelFunctionsDirect(device);


		// Retreive queue handles of queues we requested
		vkGetDeviceQueue(device, indices.indices[QueueFamily.graphics], 0, &graphicsQueue);
		vkGetDeviceQueue(device, indices.indices[QueueFamily.present],  0, &presentQueue);
	}

	void createSwapChain() {
		SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);

		VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
		VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
		VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);

		u32 imageCount = swapChainSupport.capabilities.minImageCount + 1;
		if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {
			imageCount = swapChainSupport.capabilities.maxImageCount;
		}

		VkSwapchainCreateInfoKHR createInfo;
		createInfo.surface = surface;

		createInfo.minImageCount = imageCount;
		createInfo.imageFormat = surfaceFormat.format;
		createInfo.imageColorSpace = surfaceFormat.colorSpace;
		createInfo.imageExtent = extent;
		createInfo.imageArrayLayers = 1;
		createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

		QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

		if (indices.indices[QueueFamily.graphics] != indices.indices[QueueFamily.present]) {
			createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
			createInfo.queueFamilyIndexCount = cast(u32)indices.indices.length;
			createInfo.pQueueFamilyIndices = indices.indices.ptr;
		} else {
			createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
			// createInfo.queueFamilyIndexCount = 0; // noop
			// createInfo.pQueueFamilyIndices = null; // noop
		}

		createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
		createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
		createInfo.presentMode = presentMode;
		createInfo.clipped = VK_TRUE;

		createInfo.oldSwapchain = VK_NULL_HANDLE;

		if (vkCreateSwapchainKHR(device, &createInfo, null, &swapChain) != VK_SUCCESS) {
			println("failed to create swap chain!");
			isRunning = false;
			return;
		}

		u32 swapChainImageCount;
		vkGetSwapchainImagesKHR(device, swapChain, &swapChainImageCount, null);
		swapChainImages = resizeArray[VkImage](swapChainImages, swapChainImageCount);
		vkGetSwapchainImagesKHR(device, swapChain, &swapChainImageCount, swapChainImages.ptr);

		swapChainImageFormat = surfaceFormat.format;
		swapChainExtent = extent;

		swapChainSupport.free();
	}

	void createImageViews() {
		swapChainImageViews = resizeArray[VkImageView](swapChainImageViews, swapChainImages.length);

		for (u64 i = 0; i < swapChainImages.length; ++i) {
			VkImageViewCreateInfo createInfo;
			createInfo.image = swapChainImages[i];
			createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
			createInfo.format = swapChainImageFormat;
			createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(device, &createInfo, null, &swapChainImageViews[i]) != VK_SUCCESS) {
				println("failed to create image views!");
				isRunning = false;
				return;
			}
		}
	}

	void createGraphicsPipeline() {
		u8[] vertShaderSource = readFile("../plugins/hello_triangle/res/shader.vert");
		u8[] fragShaderSource = readFile("../plugins/hello_triangle/res/shader.frag");
		if (!isRunning) return;

		shaderc_compiler_t compiler = shaderc_compiler_initialize();
		u8[] vertShaderCode = compileShader(compiler, vertShaderSource, "shader.vert", "main", shaderc_shader_kind.shaderc_glsl_vertex_shader);
		u8[] fragShaderCode = compileShader(compiler, fragShaderSource, "shader.frag", "main", shaderc_shader_kind.shaderc_glsl_fragment_shader);
		if (vertShaderCode.length == 0 || fragShaderCode.length == 0) {
			isRunning = false; // error compiling
		}
		shaderc_compiler_release(compiler);

		VkShaderModule vertShaderModule = createShaderModule(vertShaderCode);
		VkShaderModule fragShaderModule = createShaderModule(fragShaderCode);

		freeArray[u8](vertShaderCode);
		freeArray[u8](fragShaderCode);

		VkPipelineShaderStageCreateInfo vertShaderStageInfo;
		vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
		vertShaderStageInfo.Module = vertShaderModule;
		vertShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo fragShaderStageInfo;
		fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
		fragShaderStageInfo.Module = fragShaderModule;
		fragShaderStageInfo.pName = "main";

		VkPipelineShaderStageCreateInfo[2] shaderStages;
		shaderStages[0] = vertShaderStageInfo;
		shaderStages[1] = fragShaderStageInfo;

		VkPipelineVertexInputStateCreateInfo vertexInputInfo;
		vertexInputInfo.vertexBindingDescriptionCount = 0;
		vertexInputInfo.vertexAttributeDescriptionCount = 0;

		VkPipelineInputAssemblyStateCreateInfo inputAssembly;
		inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		inputAssembly.primitiveRestartEnable = VK_FALSE;

		VkViewport viewport;
		viewport.x = 0.0;
		viewport.y = 0.0;
		viewport.width = cast(f32)swapChainExtent.width;
		viewport.height = cast(f32)swapChainExtent.height;
		viewport.minDepth = 0.0;
		viewport.maxDepth = 1.0;

		VkRect2D scissor;
		scissor.offset = VkOffset2D(0, 0);
		scissor.extent = swapChainExtent;

		VkPipelineViewportStateCreateInfo viewportState;
		viewportState.viewportCount = 1;
		viewportState.pViewports = &viewport;
		viewportState.scissorCount = 1;
		viewportState.pScissors = &scissor;

		VkPipelineRasterizationStateCreateInfo rasterizer;
		rasterizer.depthClampEnable = VK_FALSE;
		rasterizer.rasterizerDiscardEnable = VK_FALSE;
		rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
		rasterizer.lineWidth = 1.0;
		rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
		rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
		rasterizer.depthBiasEnable = VK_FALSE;

		VkPipelineMultisampleStateCreateInfo multisampling;
		multisampling.sampleShadingEnable = VK_FALSE;
		multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

		VkPipelineColorBlendAttachmentState colorBlendAttachment;
		colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
		colorBlendAttachment.blendEnable = VK_FALSE;

		VkPipelineColorBlendStateCreateInfo colorBlending;
		colorBlending.logicOpEnable = VK_FALSE;
		colorBlending.logicOp = VK_LOGIC_OP_COPY;
		colorBlending.attachmentCount = 1;
		colorBlending.pAttachments = &colorBlendAttachment;
		colorBlending.blendConstants[0] = 0.0;
		colorBlending.blendConstants[1] = 0.0;
		colorBlending.blendConstants[2] = 0.0;
		colorBlending.blendConstants[3] = 0.0;

		VkPipelineLayoutCreateInfo pipelineLayoutInfo;
		pipelineLayoutInfo.setLayoutCount = 0; // Optional
		pipelineLayoutInfo.pSetLayouts = null; // Optional
		pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional
		pipelineLayoutInfo.pPushConstantRanges = null; // Optional

		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, null, &pipelineLayout) != VK_SUCCESS) {
			println("failed to create pipeline layout!");
			isRunning = false;
		}

		vkDestroyShaderModule(device, vertShaderModule, null);
		vkDestroyShaderModule(device, fragShaderModule, null);
	}

	u8[] compileShader(shaderc_compiler_t compiler, u8[] source, u8[] filename, u8* entryname, shaderc_shader_kind shader_kind) {
		shaderc_compilation_result_t result = shaderc_compile_into_spv(
			compiler, source.ptr, source.length,
			shader_kind, filename.ptr, entryname, null);

		u64 numWarnings = shaderc_result_get_num_warnings(result);
		u64 numErrors = shaderc_result_get_num_errors(result);

		shaderc_compilation_status status = shaderc_result_get_compilation_status(result);

		println("Compiled `", filename, "` with ", numWarnings, " warnings, ", numErrors, " errors, status: ", cast(u32)status);

		if (numWarnings != 0 || numErrors != 0) {
			u8* msg = shaderc_result_get_error_message(result);
			print(msg.fromStringz);
		}

		u64 resLength = shaderc_result_get_length(result);
		u8* ptr = shaderc_result_get_bytes(result);
		u8[] code = makeVoidArray[u8](resLength);
		memcopy(code, ptr[0..resLength]);

		shaderc_result_release(result);

		return code;
	}

	VkShaderModule createShaderModule(u8[] code) {
		VkShaderModuleCreateInfo createInfo;
		createInfo.codeSize = code.length; // size is in bytes
		createInfo.pCode = cast(u32*)code.ptr;

		VkShaderModule shaderModule;
		if (vkCreateShaderModule(device, &createInfo, null, &shaderModule) != VK_SUCCESS) {
			println("failed to create shader module!");
			isRunning = false;
		}
		return shaderModule;
	}

	VkSurfaceFormatKHR chooseSwapSurfaceFormat(Array[VkSurfaceFormatKHR] availableFormats) {
		for (u32 i = 0; i < availableFormats.length; ++i) {
			VkSurfaceFormatKHR availableFormat = availableFormats.ptr[i];
			if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
				return availableFormat;
			}
		}

		return availableFormats.ptr[0];
	}

	VkPresentModeKHR chooseSwapPresentMode(Array[VkPresentModeKHR] availablePresentModes) {
		for (u32 i = 0; i < availablePresentModes.length; ++i) {
			VkPresentModeKHR availablePresentMode = availablePresentModes.ptr[i];
			if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
				return availablePresentMode;
			}
		}
		return VK_PRESENT_MODE_FIFO_KHR;
	}

	VkExtent2D chooseSwapExtent(VkSurfaceCapabilitiesKHR capabilities) {
		if (capabilities.currentExtent.width != u32.max) {
			return capabilities.currentExtent;
		} else {
			i32 width;
			i32 height;
			glfwGetFramebufferSize(window, &width, &height);

			VkExtent2D actualExtent = VkExtent2D(cast(u32)width, cast(u32)height);

			actualExtent.width = clamp[u32](actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
			actualExtent.height = clamp[u32](actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

			return actualExtent;
		}
	}

	SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) {
		SwapChainSupportDetails details;

		vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);

		u32 formatCount;
		vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, null);

		if (formatCount) {
			VkSurfaceFormatKHR* ptr = details.formats.putVoid(formatCount);
			vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, ptr);
		}

		u32 presentModeCount;
		vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, null);

		if (presentModeCount != 0) {
			VkPresentModeKHR* ptr = details.presentModes.putVoid(presentModeCount);
			vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, ptr);
		}

		return details;
	}

	void onKey(i32 key, i32 scancode, i32 action, i32 mods)
	{
		println("onKey key:", key, " scancode:", scancode, " action:", action, " mods:", mods);
	}
}

struct QueueFamilyIndices {
	enum u32 NUM_FAMILIES = 2;

	QueueFamilyFlags presentFamilies; // specifies which families have valid index
	u32[NUM_FAMILIES] indices;


	bool isComplete() #inline {
		enum requiredFamilies = QueueFamilyFlags.graphics | QueueFamilyFlags.present;
		return (presentFamilies & requiredFamilies) == requiredFamilies;
	}
}

enum QueueFamily : u32 {
	graphics = 0,
	present  = 1,
}
enum QueueFamilyFlags : u32 {
	graphics = 0b0000_0001,
	present  = 0b0000_0010,
}

u32 debugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
	void* pUserData) {

	println("validation layer: ", pCallbackData.pMessage.fromStringz);

	return VK_FALSE;
}

bool checkLayers(u8*[] requestedLayers, VkLayerProperties[] availableLayers)
{
	for (i32 i; i < requestedLayers.length; ++i) {
		u8[] requestedLayer = requestedLayers[i].fromStringz;
		//println("req ", requestedLayer);
		bool layerFound = false;
		for (i32 j; j < availableLayers.length; ++j) {
			u8[] name = availableLayers[j].layerName.ptr.fromStringz;
			//println("  ", name, " ", availableLayers[j].specVersion, " ", availableLayers[j].implementationVersion, " ", availableLayers[j].description.ptr.fromStringz);
			if (equal[u8[]](name, requestedLayer)) {
				layerFound = true;
				break;
			}
		}
		if (!layerFound) {
			return false;
		}
	}
	return true;
}

bool checkExtensions(u8*[] requestedExtensions, VkExtensionProperties[] availableExtensions)
{
	for (i32 i; i < requestedExtensions.length; ++i) {
		u8[] requestedExtension = requestedExtensions[i].fromStringz;
		bool extensionFound = false;
		for (i32 j; j < availableExtensions.length; ++j) {
			u8[] name = availableExtensions[j].extensionName.ptr.fromStringz;
			if (equal[u8[]](name, requestedExtension)) {
				extensionFound = true;
				break;
			}
		}
		if (!extensionFound) {
			return false;
		}
	}
	return true;
}

void glfw_key_callback(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods)
{
	Client* client = cast(Client*)glfwGetWindowUserPointer(window);
	client.onKey(key, scancode, action, mods);
}
